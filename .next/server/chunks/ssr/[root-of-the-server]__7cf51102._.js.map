{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/actions/doctor.js"],"sourcesContent":["\"use server\";\n\nimport { db } from \"@/lib/prisma\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { revalidatePath } from \"next/cache\";\n\n/**\n * Set doctor's availability slots\n */\nexport async function setAvailabilitySlots(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    // Get the doctor\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    // Get form data\n    const startTime = formData.get(\"startTime\");\n    const endTime = formData.get(\"endTime\");\n\n    // Validate input\n    if (!startTime || !endTime) {\n      throw new Error(\"Start time and end time are required\");\n    }\n\n    if (startTime >= endTime) {\n      throw new Error(\"Start time must be before end time\");\n    }\n\n    // Check if the doctor already has slots\n    const existingSlots = await db.availability.findMany({\n      where: {\n        doctorId: doctor.id,\n      },\n    });\n\n    // If slots exist, delete them all (we're replacing them)\n    if (existingSlots.length > 0) {\n      // Don't delete slots that already have appointments\n      const slotsWithNoAppointments = existingSlots.filter(\n        (slot) => !slot.appointment\n      );\n\n      if (slotsWithNoAppointments.length > 0) {\n        await db.availability.deleteMany({\n          where: {\n            id: {\n              in: slotsWithNoAppointments.map((slot) => slot.id),\n            },\n          },\n        });\n      }\n    }\n\n    // Create new availability slot\n    const newSlot = await db.availability.create({\n      data: {\n        doctorId: doctor.id,\n        startTime: new Date(startTime),\n        endTime: new Date(endTime),\n        status: \"AVAILABLE\",\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, slot: newSlot };\n  } catch (error) {\n    console.error(\"Failed to set availability slots:\", error);\n    throw new Error(\"Failed to set availability: \" + error.message);\n  }\n}\n\n/**\n * Get doctor's current availability slots\n */\nexport async function getDoctorAvailability() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const availabilitySlots = await db.availability.findMany({\n      where: {\n        doctorId: doctor.id,\n      },\n      orderBy: {\n        startTime: \"asc\",\n      },\n    });\n\n    return { slots: availabilitySlots };\n  } catch (error) {\n    throw new Error(\"Failed to fetch availability slots \" + error.message);\n  }\n}\n\n/**\n * Get doctor's upcoming appointments\n */\n\nexport async function getDoctorAppointments() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointments = await db.appointment.findMany({\n      where: {\n        doctorId: doctor.id,\n        status: {\n          in: [\"SCHEDULED\"],\n        },\n      },\n      include: {\n        patient: true,\n      },\n      orderBy: {\n        startTime: \"asc\",\n      },\n    });\n\n    return { appointments };\n  } catch (error) {\n    throw new Error(\"Failed to fetch appointments \" + error.message);\n  }\n}\n\n/**\n * Cancel an appointment (can be done by both doctor and patient)\n */\nexport async function cancelAppointment(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const user = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n      },\n    });\n\n    if (!user) {\n      throw new Error(\"User not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n\n    if (!appointmentId) {\n      throw new Error(\"Appointment ID is required\");\n    }\n\n    // Find the appointment with both patient and doctor details\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n      },\n      include: {\n        patient: true,\n        doctor: true,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found\");\n    }\n\n    // Verify the user is either the doctor or the patient for this appointment\n    if (appointment.doctorId !== user.id && appointment.patientId !== user.id) {\n      throw new Error(\"You are not authorized to cancel this appointment\");\n    }\n\n    // Perform cancellation in a transaction\n    await db.$transaction(async (tx) => {\n      // Update the appointment status to CANCELLED\n      await tx.appointment.update({\n        where: {\n          id: appointmentId,\n        },\n        data: {\n          status: \"CANCELLED\",\n        },\n      });\n\n      // Always refund credits to patient and deduct from doctor\n      // Create credit transaction for patient (refund)\n      await tx.creditTransaction.create({\n        data: {\n          userId: appointment.patientId,\n          amount: 2,\n          type: \"APPOINTMENT_DEDUCTION\",\n        },\n      });\n\n      // Create credit transaction for doctor (deduction)\n      await tx.creditTransaction.create({\n        data: {\n          userId: appointment.doctorId,\n          amount: -2,\n          type: \"APPOINTMENT_DEDUCTION\",\n        },\n      });\n\n      // Update patient's credit balance (increment)\n      await tx.user.update({\n        where: {\n          id: appointment.patientId,\n        },\n        data: {\n          credits: {\n            increment: 2,\n          },\n        },\n      });\n\n      // Update doctor's credit balance (decrement)\n      await tx.user.update({\n        where: {\n          id: appointment.doctorId,\n        },\n        data: {\n          credits: {\n            decrement: 2,\n          },\n        },\n      });\n    });\n\n    // Determine which path to revalidate based on user role\n    if (user.role === \"DOCTOR\") {\n      revalidatePath(\"/doctor\");\n    } else if (user.role === \"PATIENT\") {\n      revalidatePath(\"/appointments\");\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Failed to cancel appointment:\", error);\n    throw new Error(\"Failed to cancel appointment: \" + error.message);\n  }\n}\n\n/**\n * Add notes to an appointment\n */\nexport async function addAppointmentNotes(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n    const notes = formData.get(\"notes\");\n\n    if (!appointmentId || !notes) {\n      throw new Error(\"Appointment ID and notes are required\");\n    }\n\n    // Verify the appointment belongs to this doctor\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n        doctorId: doctor.id,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found\");\n    }\n\n    // Update the appointment notes\n    const updatedAppointment = await db.appointment.update({\n      where: {\n        id: appointmentId,\n      },\n      data: {\n        notes,\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, appointment: updatedAppointment };\n  } catch (error) {\n    console.error(\"Failed to add appointment notes:\", error);\n    throw new Error(\"Failed to update notes: \" + error.message);\n  }\n}\n\n/**\n * Mark an appointment as completed (only by doctor after end time)\n */\nexport async function markAppointmentCompleted(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n\n    if (!appointmentId) {\n      throw new Error(\"Appointment ID is required\");\n    }\n\n    // Find the appointment\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n        doctorId: doctor.id, // Ensure appointment belongs to this doctor\n      },\n      include: {\n        patient: true,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found or not authorized\");\n    }\n\n    // Check if appointment is currently scheduled\n    if (appointment.status !== \"SCHEDULED\") {\n      throw new Error(\"Only scheduled appointments can be marked as completed\");\n    }\n\n    // Check if current time is after the appointment end time\n    const now = new Date();\n    const appointmentEndTime = new Date(appointment.endTime);\n\n    if (now < appointmentEndTime) {\n      throw new Error(\n        \"Cannot mark appointment as completed before the scheduled end time\"\n      );\n    }\n\n    // Update the appointment status to COMPLETED\n    const updatedAppointment = await db.appointment.update({\n      where: {\n        id: appointmentId,\n      },\n      data: {\n        status: \"COMPLETED\",\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, appointment: updatedAppointment };\n  } catch (error) {\n    console.error(\"Failed to mark appointment as completed:\", error);\n    throw new Error(\n      \"Failed to mark appointment as completed: \" + error.message\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 390, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/actions/onboarding.js"],"sourcesContent":["\"use server\";\n\nimport { db } from \"@/lib/prisma\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { revalidatePath } from \"next/cache\";\n\n/**\n * Sets the user's role and related information\n */\nexport async function setUserRole(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  // Find user in our database\n  const user = await db.user.findUnique({\n    where: { clerkUserId: userId },\n  });\n\n  if (!user) throw new Error(\"User not found in database\");\n\n  const role = formData.get(\"role\");\n\n  if (!role || ![\"PATIENT\", \"DOCTOR\"].includes(role)) {\n    throw new Error(\"Invalid role selection\");\n  }\n\n  try {\n    // For patient role - simple update\n    if (role === \"PATIENT\") {\n      await db.user.update({\n        where: {\n          clerkUserId: userId,\n        },\n        data: {\n          role: \"PATIENT\",\n        },\n      });\n\n      revalidatePath(\"/\");\n      return { success: true, redirect: \"/doctors\" };\n    }\n\n    // For doctor role - need additional information\n    if (role === \"DOCTOR\") {\n      const specialty = formData.get(\"specialty\");\n      const experience = parseInt(formData.get(\"experience\"), 10);\n      const credentialUrl = formData.get(\"credentialUrl\");\n      const description = formData.get(\"description\");\n\n      // Validate inputs\n      if (!specialty || !experience || !credentialUrl || !description) {\n        throw new Error(\"All fields are required\");\n      }\n\n      await db.user.update({\n        where: {\n          clerkUserId: userId,\n        },\n        data: {\n          role: \"DOCTOR\",\n          specialty,\n          experience,\n          credentialUrl,\n          description,\n          verificationStatus: \"PENDING\",\n        },\n      });\n\n      revalidatePath(\"/\");\n      return { success: true, redirect: \"/doctor/verification\" };\n    }\n  } catch (error) {\n    console.error(\"Failed to set user role:\", error);\n    throw new Error(`Failed to update user profile: ${error.message}`);\n  }\n}\n\n/**\n * Gets the current user's complete profile information\n */\nexport async function getCurrentUser() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    return null;\n  }\n\n  try {\n    const user = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n      },\n    });\n\n    return user;\n  } catch (error) {\n    console.error(\"Failed to get user information:\", error);\n    return null;\n  }\n}\n"],"names":[],"mappings":";;;;;;AAEA;AACA;AACA;;;;;;;AAKO,eAAe,YAAY,QAAQ;IACxC,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,mLAAA,CAAA,OAAI,AAAD;IAE5B,IAAI,CAAC,QAAQ;QACX,MAAM,IAAI,MAAM;IAClB;IAEA,4BAA4B;IAC5B,MAAM,OAAO,MAAM,6GAAA,CAAA,KAAE,CAAC,IAAI,CAAC,UAAU,CAAC;QACpC,OAAO;YAAE,aAAa;QAAO;IAC/B;IAEA,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;IAE3B,MAAM,OAAO,SAAS,GAAG,CAAC;IAE1B,IAAI,CAAC,QAAQ,CAAC;QAAC;QAAW;KAAS,CAAC,QAAQ,CAAC,OAAO;QAClD,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI;QACF,mCAAmC;QACnC,IAAI,SAAS,WAAW;YACtB,MAAM,6GAAA,CAAA,KAAE,CAAC,IAAI,CAAC,MAAM,CAAC;gBACnB,OAAO;oBACL,aAAa;gBACf;gBACA,MAAM;oBACJ,MAAM;gBACR;YACF;YAEA,CAAA,GAAA,6HAAA,CAAA,iBAAc,AAAD,EAAE;YACf,OAAO;gBAAE,SAAS;gBAAM,UAAU;YAAW;QAC/C;QAEA,gDAAgD;QAChD,IAAI,SAAS,UAAU;YACrB,MAAM,YAAY,SAAS,GAAG,CAAC;YAC/B,MAAM,aAAa,SAAS,SAAS,GAAG,CAAC,eAAe;YACxD,MAAM,gBAAgB,SAAS,GAAG,CAAC;YACnC,MAAM,cAAc,SAAS,GAAG,CAAC;YAEjC,kBAAkB;YAClB,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,iBAAiB,CAAC,aAAa;gBAC/D,MAAM,IAAI,MAAM;YAClB;YAEA,MAAM,6GAAA,CAAA,KAAE,CAAC,IAAI,CAAC,MAAM,CAAC;gBACnB,OAAO;oBACL,aAAa;gBACf;gBACA,MAAM;oBACJ,MAAM;oBACN;oBACA;oBACA;oBACA;oBACA,oBAAoB;gBACtB;YACF;YAEA,CAAA,GAAA,6HAAA,CAAA,iBAAc,AAAD,EAAE;YACf,OAAO;gBAAE,SAAS;gBAAM,UAAU;YAAuB;QAC3D;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,MAAM,OAAO,EAAE;IACnE;AACF;AAKO,eAAe;IACpB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,mLAAA,CAAA,OAAI,AAAD;IAE5B,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IAEA,IAAI;QACF,MAAM,OAAO,MAAM,6GAAA,CAAA,KAAE,CAAC,IAAI,CAAC,UAAU,CAAC;YACpC,OAAO;gBACL,aAAa;YACf;QACF;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO;IACT;AACF;;;IA7FsB;IA0EA;;AA1EA,+OAAA;AA0EA,+OAAA","debugId":null}},
    {"offset": {"line": 505, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/actions/payout.js"],"sourcesContent":["\"use server\";\n\nimport { db } from \"@/lib/prisma\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { revalidatePath } from \"next/cache\";\n\nconst CREDIT_VALUE = 10; // $10 per credit total\nconst PLATFORM_FEE_PER_CREDIT = 2; // $2 platform fee\nconst DOCTOR_EARNINGS_PER_CREDIT = 8; // $8 to doctor\n\n/**\n * Request payout for all remaining credits\n */\nexport async function requestPayout(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const paypalEmail = formData.get(\"paypalEmail\");\n\n    if (!paypalEmail) {\n      throw new Error(\"PayPal email is required\");\n    }\n\n    // Check if doctor has any pending payout requests\n    const existingPendingPayout = await db.payout.findFirst({\n      where: {\n        doctorId: doctor.id,\n        status: \"PROCESSING\",\n      },\n    });\n\n    if (existingPendingPayout) {\n      throw new Error(\n        \"You already have a pending payout request. Please wait for it to be processed.\"\n      );\n    }\n\n    // Get doctor's current credit balance\n    const creditCount = doctor.credits;\n\n    if (creditCount === 0) {\n      throw new Error(\"No credits available for payout\");\n    }\n\n    if (creditCount < 1) {\n      throw new Error(\"Minimum 1 credit required for payout\");\n    }\n\n    const totalAmount = creditCount * CREDIT_VALUE;\n    const platformFee = creditCount * PLATFORM_FEE_PER_CREDIT;\n    const netAmount = creditCount * DOCTOR_EARNINGS_PER_CREDIT;\n\n    // Create payout request\n    const payout = await db.payout.create({\n      data: {\n        doctorId: doctor.id,\n        amount: totalAmount,\n        credits: creditCount,\n        platformFee,\n        netAmount,\n        paypalEmail,\n        status: \"PROCESSING\",\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, payout };\n  } catch (error) {\n    console.error(\"Failed to request payout:\", error);\n    throw new Error(\"Failed to request payout: \" + error.message);\n  }\n}\n\n/**\n * Get doctor's payout history\n */\nexport async function getDoctorPayouts() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const payouts = await db.payout.findMany({\n      where: {\n        doctorId: doctor.id,\n      },\n      orderBy: {\n        createdAt: \"desc\",\n      },\n    });\n\n    return { payouts };\n  } catch (error) {\n    throw new Error(\"Failed to fetch payouts: \" + error.message);\n  }\n}\n\n/**\n * Get doctor's earnings summary\n */\nexport async function getDoctorEarnings() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    // Get all completed appointments for this doctor\n    const completedAppointments = await db.appointment.findMany({\n      where: {\n        doctorId: doctor.id,\n        status: \"COMPLETED\",\n      },\n    });\n\n    // Calculate this month's completed appointments\n    const currentMonth = new Date();\n    currentMonth.setDate(1);\n    currentMonth.setHours(0, 0, 0, 0);\n\n    const thisMonthAppointments = completedAppointments.filter(\n      (appointment) => new Date(appointment.createdAt) >= currentMonth\n    );\n\n    // Use doctor's actual credits from the user model\n    const totalEarnings = doctor.credits * DOCTOR_EARNINGS_PER_CREDIT; // $8 per credit to doctor\n\n    // Calculate this month's earnings (2 credits per appointment * $8 per credit)\n    const thisMonthEarnings =\n      thisMonthAppointments.length * 2 * DOCTOR_EARNINGS_PER_CREDIT;\n\n    // Simple average per month calculation\n    const averageEarningsPerMonth =\n      totalEarnings > 0\n        ? totalEarnings / Math.max(1, new Date().getMonth() + 1)\n        : 0;\n\n    // Get current credit balance for payout calculations\n    const availableCredits = doctor.credits;\n    const availablePayout = availableCredits * DOCTOR_EARNINGS_PER_CREDIT;\n\n    return {\n      earnings: {\n        totalEarnings,\n        thisMonthEarnings,\n        completedAppointments: completedAppointments.length,\n        averageEarningsPerMonth,\n        availableCredits,\n        availablePayout,\n      },\n    };\n  } catch (error) {\n    throw new Error(\"Failed to fetch doctor earnings: \" + error.message);\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 777, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/actions/appointments.js"],"sourcesContent":["\"use server\";\n\nimport { db } from \"@/lib/prisma\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { revalidatePath } from \"next/cache\";\nimport { deductCreditsForAppointment } from \"@/actions/credits\";\nimport { Vonage } from \"@vonage/server-sdk\";\nimport { addDays, addMinutes, format, isBefore, endOfDay } from \"date-fns\";\nimport { Auth } from \"@vonage/auth\";\n\n// Initialize Vonage Video API client\nconst credentials = new Auth({\n  applicationId: process.env.NEXT_PUBLIC_VONAGE_APPLICATION_ID,\n  privateKey: process.env.VONAGE_PRIVATE_KEY,\n});\nconst options = {};\nconst vonage = new Vonage(credentials, options);\n\n/**\n * Book a new appointment with a doctor\n */\nexport async function bookAppointment(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    // Get the patient user\n    const patient = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"PATIENT\",\n      },\n    });\n\n    if (!patient) {\n      throw new Error(\"Patient not found\");\n    }\n\n    // Parse form data\n    const doctorId = formData.get(\"doctorId\");\n    const startTime = new Date(formData.get(\"startTime\"));\n    const endTime = new Date(formData.get(\"endTime\"));\n    const patientDescription = formData.get(\"description\") || null;\n\n    // Validate input\n    if (!doctorId || !startTime || !endTime) {\n      throw new Error(\"Doctor, start time, and end time are required\");\n    }\n\n    // Check if the doctor exists and is verified\n    const doctor = await db.user.findUnique({\n      where: {\n        id: doctorId,\n        role: \"DOCTOR\",\n        verificationStatus: \"VERIFIED\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found or not verified\");\n    }\n\n    // Check if the patient has enough credits (2 credits per appointment)\n    if (patient.credits < 2) {\n      throw new Error(\"Insufficient credits to book an appointment\");\n    }\n\n    // Check if the requested time slot is available\n    const overlappingAppointment = await db.appointment.findFirst({\n      where: {\n        doctorId: doctorId,\n        status: \"SCHEDULED\",\n        OR: [\n          {\n            // New appointment starts during an existing appointment\n            startTime: {\n              lte: startTime,\n            },\n            endTime: {\n              gt: startTime,\n            },\n          },\n          {\n            // New appointment ends during an existing appointment\n            startTime: {\n              lt: endTime,\n            },\n            endTime: {\n              gte: endTime,\n            },\n          },\n          {\n            // New appointment completely overlaps an existing appointment\n            startTime: {\n              gte: startTime,\n            },\n            endTime: {\n              lte: endTime,\n            },\n          },\n        ],\n      },\n    });\n\n    if (overlappingAppointment) {\n      throw new Error(\"This time slot is already booked\");\n    }\n\n    // Create a new Vonage Video API session\n    const sessionId = await createVideoSession();\n\n    // Deduct credits from patient and add to doctor\n    const { success, error } = await deductCreditsForAppointment(\n      patient.id,\n      doctor.id\n    );\n\n    if (!success) {\n      throw new Error(error || \"Failed to deduct credits\");\n    }\n\n    // Create the appointment with the video session ID\n    const appointment = await db.appointment.create({\n      data: {\n        patientId: patient.id,\n        doctorId: doctor.id,\n        startTime,\n        endTime,\n        patientDescription,\n        status: \"SCHEDULED\",\n        videoSessionId: sessionId, // Store the Vonage session ID\n      },\n    });\n\n    revalidatePath(\"/appointments\");\n    return { success: true, appointment: appointment };\n  } catch (error) {\n    console.error(\"Failed to book appointment:\", error);\n    throw new Error(\"Failed to book appointment:\" + error.message);\n  }\n}\n\n/**\n * Generate a Vonage Video API session\n */\nasync function createVideoSession() {\n  try {\n    const session = await vonage.video.createSession({ mediaMode: \"routed\" });\n    return session.sessionId;\n  } catch (error) {\n    throw new Error(\"Failed to create video session: \" + error.message);\n  }\n}\n\n/**\n * Generate a token for a video session\n * This will be called when either doctor or patient is about to join the call\n */\nexport async function generateVideoToken(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const user = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n      },\n    });\n\n    if (!user) {\n      throw new Error(\"User not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n\n    if (!appointmentId) {\n      throw new Error(\"Appointment ID is required\");\n    }\n\n    // Find the appointment and verify the user is part of it\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found\");\n    }\n\n    // Verify the user is either the doctor or the patient for this appointment\n    if (appointment.doctorId !== user.id && appointment.patientId !== user.id) {\n      throw new Error(\"You are not authorized to join this call\");\n    }\n\n    // Verify the appointment is scheduled\n    if (appointment.status !== \"SCHEDULED\") {\n      throw new Error(\"This appointment is not currently scheduled\");\n    }\n\n    // Verify the appointment is within a valid time range (e.g., starting 5 minutes before scheduled time)\n    const now = new Date();\n    const appointmentTime = new Date(appointment.startTime);\n    const timeDifference = (appointmentTime - now) / (1000 * 60); // difference in minutes\n\n    if (timeDifference > 30) {\n      throw new Error(\n        \"The call will be available 30 minutes before the scheduled time\"\n      );\n    }\n\n    // Generate a token for the video session\n    // Token expires 2 hours after the appointment start time\n    const appointmentEndTime = new Date(appointment.endTime);\n    const expirationTime =\n      Math.floor(appointmentEndTime.getTime() / 1000) + 60 * 60; // 1 hour after end time\n\n    // Use user's name and role as connection data\n    const connectionData = JSON.stringify({\n      name: user.name,\n      role: user.role,\n      userId: user.id,\n    });\n\n    // Generate the token with appropriate role and expiration\n    const token = vonage.video.generateClientToken(appointment.videoSessionId, {\n      role: \"publisher\", // Both doctor and patient can publish streams\n      expireTime: expirationTime,\n      data: connectionData,\n    });\n\n    // Update the appointment with the token\n    await db.appointment.update({\n      where: {\n        id: appointmentId,\n      },\n      data: {\n        videoSessionToken: token,\n      },\n    });\n\n    return {\n      success: true,\n      videoSessionId: appointment.videoSessionId,\n      token: token,\n    };\n  } catch (error) {\n    console.error(\"Failed to generate video token:\", error);\n    throw new Error(\"Failed to generate video token:\" + error.message);\n  }\n}\n\n/**\n * Get doctor by ID\n */\nexport async function getDoctorById(doctorId) {\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        id: doctorId,\n        role: \"DOCTOR\",\n        verificationStatus: \"VERIFIED\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    return { doctor };\n  } catch (error) {\n    console.error(\"Failed to fetch doctor:\", error);\n    throw new Error(\"Failed to fetch doctor details\");\n  }\n}\n\n/**\n * Get available time slots for booking for the next 4 days\n */\nexport async function getAvailableTimeSlots(doctorId) {\n  try {\n    // Validate doctor existence and verification\n    const doctor = await db.user.findUnique({\n      where: {\n        id: doctorId,\n        role: \"DOCTOR\",\n        verificationStatus: \"VERIFIED\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found or not verified\");\n    }\n\n    // Fetch a single availability record\n    const availability = await db.availability.findFirst({\n      where: {\n        doctorId: doctor.id,\n        status: \"AVAILABLE\",\n      },\n    });\n\n    if (!availability) {\n      throw new Error(\"No availability set by doctor\");\n    }\n\n    // Get the next 4 days\n    const now = new Date();\n    const days = [now, addDays(now, 1), addDays(now, 2), addDays(now, 3)];\n\n    // Fetch existing appointments for the doctor over the next 4 days\n    const lastDay = endOfDay(days[3]);\n    const existingAppointments = await db.appointment.findMany({\n      where: {\n        doctorId: doctor.id,\n        status: \"SCHEDULED\",\n        startTime: {\n          lte: lastDay,\n        },\n      },\n    });\n\n    const availableSlotsByDay = {};\n\n    // For each of the next 4 days, generate available slots\n    for (const day of days) {\n      const dayString = format(day, \"yyyy-MM-dd\");\n      availableSlotsByDay[dayString] = [];\n\n      // Create a copy of the availability start/end times for this day\n      const availabilityStart = new Date(availability.startTime);\n      const availabilityEnd = new Date(availability.endTime);\n\n      // Set the day to the current day we're processing\n      availabilityStart.setFullYear(\n        day.getFullYear(),\n        day.getMonth(),\n        day.getDate()\n      );\n      availabilityEnd.setFullYear(\n        day.getFullYear(),\n        day.getMonth(),\n        day.getDate()\n      );\n\n      let current = new Date(availabilityStart);\n      const end = new Date(availabilityEnd);\n\n      while (\n        isBefore(addMinutes(current, 30), end) ||\n        +addMinutes(current, 30) === +end\n      ) {\n        const next = addMinutes(current, 30);\n\n        // Skip past slots\n        if (isBefore(current, now)) {\n          current = next;\n          continue;\n        }\n\n        const overlaps = existingAppointments.some((appointment) => {\n          const aStart = new Date(appointment.startTime);\n          const aEnd = new Date(appointment.endTime);\n\n          return (\n            (current >= aStart && current < aEnd) ||\n            (next > aStart && next <= aEnd) ||\n            (current <= aStart && next >= aEnd)\n          );\n        });\n\n        if (!overlaps) {\n          availableSlotsByDay[dayString].push({\n            startTime: current.toISOString(),\n            endTime: next.toISOString(),\n            formatted: `${format(current, \"h:mm a\")} - ${format(\n              next,\n              \"h:mm a\"\n            )}`,\n            day: format(current, \"EEEE, MMMM d\"),\n          });\n        }\n\n        current = next;\n      }\n    }\n\n    // Convert to array of slots grouped by day for easier consumption by the UI\n    const result = Object.entries(availableSlotsByDay).map(([date, slots]) => ({\n      date,\n      displayDate:\n        slots.length > 0\n          ? slots[0].day\n          : format(new Date(date), \"EEEE, MMMM d\"),\n      slots,\n    }));\n\n    return { days: result };\n  } catch (error) {\n    console.error(\"Failed to fetch available slots:\", error);\n    throw new Error(\"Failed to fetch available time slots: \" + error.message);\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1163, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/components/ui/tabs.jsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const Tabs = registerClientReference(\n    function() { throw new Error(\"Attempted to call Tabs() from the server but Tabs is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/ui/tabs.jsx <module evaluation>\",\n    \"Tabs\",\n);\nexport const TabsContent = registerClientReference(\n    function() { throw new Error(\"Attempted to call TabsContent() from the server but TabsContent is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/ui/tabs.jsx <module evaluation>\",\n    \"TabsContent\",\n);\nexport const TabsList = registerClientReference(\n    function() { throw new Error(\"Attempted to call TabsList() from the server but TabsList is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/ui/tabs.jsx <module evaluation>\",\n    \"TabsList\",\n);\nexport const TabsTrigger = registerClientReference(\n    function() { throw new Error(\"Attempted to call TabsTrigger() from the server but TabsTrigger is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/ui/tabs.jsx <module evaluation>\",\n    \"TabsTrigger\",\n);\n"],"names":[],"mappings":";;;;;;AAAA;;AACO,MAAM,OAAO,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACtC;IAAa,MAAM,IAAI,MAAM;AAAwN,GACrP,wDACA;AAEG,MAAM,cAAc,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC7C;IAAa,MAAM,IAAI,MAAM;AAAsO,GACnQ,wDACA;AAEG,MAAM,WAAW,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC1C;IAAa,MAAM,IAAI,MAAM;AAAgO,GAC7P,wDACA;AAEG,MAAM,cAAc,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC7C;IAAa,MAAM,IAAI,MAAM;AAAsO,GACnQ,wDACA","debugId":null}},
    {"offset": {"line": 1189, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/components/ui/tabs.jsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const Tabs = registerClientReference(\n    function() { throw new Error(\"Attempted to call Tabs() from the server but Tabs is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/ui/tabs.jsx\",\n    \"Tabs\",\n);\nexport const TabsContent = registerClientReference(\n    function() { throw new Error(\"Attempted to call TabsContent() from the server but TabsContent is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/ui/tabs.jsx\",\n    \"TabsContent\",\n);\nexport const TabsList = registerClientReference(\n    function() { throw new Error(\"Attempted to call TabsList() from the server but TabsList is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/ui/tabs.jsx\",\n    \"TabsList\",\n);\nexport const TabsTrigger = registerClientReference(\n    function() { throw new Error(\"Attempted to call TabsTrigger() from the server but TabsTrigger is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/ui/tabs.jsx\",\n    \"TabsTrigger\",\n);\n"],"names":[],"mappings":";;;;;;AAAA;;AACO,MAAM,OAAO,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACtC;IAAa,MAAM,IAAI,MAAM;AAAwN,GACrP,oCACA;AAEG,MAAM,cAAc,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC7C;IAAa,MAAM,IAAI,MAAM;AAAsO,GACnQ,oCACA;AAEG,MAAM,WAAW,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC1C;IAAa,MAAM,IAAI,MAAM;AAAgO,GAC7P,oCACA;AAEG,MAAM,cAAc,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC7C;IAAa,MAAM,IAAI,MAAM;AAAsO,GACnQ,oCACA","debugId":null}},
    {"offset": {"line": 1215, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1225, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/app/%28main%29/doctor/_components/availability-settings.jsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const AvailabilitySettings = registerClientReference(\n    function() { throw new Error(\"Attempted to call AvailabilitySettings() from the server but AvailabilitySettings is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/(main)/doctor/_components/availability-settings.jsx <module evaluation>\",\n    \"AvailabilitySettings\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,uBAAuB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACtD;IAAa,MAAM,IAAI,MAAM;AAAwP,GACrR,yFACA","debugId":null}},
    {"offset": {"line": 1239, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/app/%28main%29/doctor/_components/availability-settings.jsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const AvailabilitySettings = registerClientReference(\n    function() { throw new Error(\"Attempted to call AvailabilitySettings() from the server but AvailabilitySettings is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/(main)/doctor/_components/availability-settings.jsx\",\n    \"AvailabilitySettings\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,uBAAuB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACtD;IAAa,MAAM,IAAI,MAAM;AAAwP,GACrR,qEACA","debugId":null}},
    {"offset": {"line": 1253, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1263, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/app/%28main%29/doctor/_components/appointments-list.jsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/app/(main)/doctor/_components/appointments-list.jsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/(main)/doctor/_components/appointments-list.jsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAuT,GACpV,qFACA","debugId":null}},
    {"offset": {"line": 1277, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/app/%28main%29/doctor/_components/appointments-list.jsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/app/(main)/doctor/_components/appointments-list.jsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/(main)/doctor/_components/appointments-list.jsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAmS,GAChU,iEACA","debugId":null}},
    {"offset": {"line": 1291, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1301, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/app/%28main%29/doctor/_components/doctor-earnings.jsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const DoctorEarnings = registerClientReference(\n    function() { throw new Error(\"Attempted to call DoctorEarnings() from the server but DoctorEarnings is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/(main)/doctor/_components/doctor-earnings.jsx <module evaluation>\",\n    \"DoctorEarnings\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,iBAAiB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAChD;IAAa,MAAM,IAAI,MAAM;AAA4O,GACzQ,mFACA","debugId":null}},
    {"offset": {"line": 1315, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/app/%28main%29/doctor/_components/doctor-earnings.jsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const DoctorEarnings = registerClientReference(\n    function() { throw new Error(\"Attempted to call DoctorEarnings() from the server but DoctorEarnings is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/(main)/doctor/_components/doctor-earnings.jsx\",\n    \"DoctorEarnings\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,iBAAiB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAChD;IAAa,MAAM,IAAI,MAAM;AAA4O,GACzQ,+DACA","debugId":null}},
    {"offset": {"line": 1329, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1339, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/app/%28main%29/doctor/page.jsx"],"sourcesContent":["import { Tabs, TabsList, TabsTrigger, TabsContent } from \"@/components/ui/tabs\";\nimport { getDoctorAppointments, getDoctorAvailability } from \"@/actions/doctor\";\nimport { AvailabilitySettings } from \"./_components/availability-settings\";\nimport { getCurrentUser } from \"@/actions/onboarding\";\nimport { redirect } from \"next/navigation\";\nimport { Calendar, Clock, DollarSign } from \"lucide-react\";\nimport DoctorAppointmentsList from \"./_components/appointments-list\";\nimport { getDoctorEarnings, getDoctorPayouts } from \"@/actions/payout\";\nimport { DoctorEarnings } from \"./_components/doctor-earnings\";\n\nexport default async function DoctorDashboardPage() {\n  const user = await getCurrentUser();\n\n  const [appointmentsData, availabilityData, earningsData, payoutsData] =\n    await Promise.all([\n      getDoctorAppointments(),\n      getDoctorAvailability(),\n      getDoctorEarnings(),\n      getDoctorPayouts(),\n    ]);\n\n  //   // Redirect if not a doctor\n  if (user?.role !== \"DOCTOR\") {\n    redirect(\"/onboarding\");\n  }\n\n  // If already verified, redirect to dashboard\n  if (user?.verificationStatus !== \"VERIFIED\") {\n    redirect(\"/doctor/verification\");\n  }\n\n  return (\n    <Tabs\n      defaultValue=\"earnings\"\n      className=\"grid grid-cols-1 md:grid-cols-4 gap-6\"\n    >\n      <TabsList className=\"md:col-span-1 bg-muted/30 border h-14 md:h-40 flex sm:flex-row md:flex-col w-full p-2 md:p-1 rounded-md md:space-y-2 sm:space-x-2 md:space-x-0\">\n        <TabsTrigger\n          value=\"earnings\"\n          className=\"flex-1 md:flex md:items-center md:justify-start md:px-4 md:py-3 w-full\"\n        >\n          <DollarSign className=\"h-4 w-4 mr-2 hidden md:inline\" />\n          <span>Earnings</span>\n        </TabsTrigger>\n        <TabsTrigger\n          value=\"appointments\"\n          className=\"flex-1 md:flex md:items-center md:justify-start md:px-4 md:py-3 w-full\"\n        >\n          <Calendar className=\"h-4 w-4 mr-2 hidden md:inline\" />\n          <span>Appointments</span>\n        </TabsTrigger>\n        <TabsTrigger\n          value=\"availability\"\n          className=\"flex-1 md:flex md:items-center md:justify-start md:px-4 md:py-3 w-full\"\n        >\n          <Clock className=\"h-4 w-4 mr-2 hidden md:inline\" />\n          <span>Availability</span>\n        </TabsTrigger>\n      </TabsList>\n      <div className=\"md:col-span-3\">\n        <TabsContent value=\"appointments\" className=\"border-none p-0\">\n          <DoctorAppointmentsList\n            appointments={appointmentsData.appointments || []}\n          />\n        </TabsContent>\n        <TabsContent value=\"availability\" className=\"border-none p-0\">\n          <AvailabilitySettings slots={availabilityData.slots || []} />\n        </TabsContent>\n        <TabsContent value=\"earnings\" className=\"border-none p-0\">\n          <DoctorEarnings\n            earnings={earningsData.earnings || {}}\n            payouts={payoutsData.payouts || []}\n          />\n        </TabsContent>\n      </div>\n    </Tabs>\n  );\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;AAEe,eAAe;IAC5B,MAAM,OAAO,MAAM,CAAA,GAAA,qHAAA,CAAA,iBAAc,AAAD;IAEhC,MAAM,CAAC,kBAAkB,kBAAkB,cAAc,YAAY,GACnE,MAAM,QAAQ,GAAG,CAAC;QAChB,CAAA,GAAA,iHAAA,CAAA,wBAAqB,AAAD;QACpB,CAAA,GAAA,iHAAA,CAAA,wBAAqB,AAAD;QACpB,CAAA,GAAA,iHAAA,CAAA,oBAAiB,AAAD;QAChB,CAAA,GAAA,iHAAA,CAAA,mBAAgB,AAAD;KAChB;IAEH,gCAAgC;IAChC,IAAI,MAAM,SAAS,UAAU;QAC3B,CAAA,GAAA,qLAAA,CAAA,WAAQ,AAAD,EAAE;IACX;IAEA,6CAA6C;IAC7C,IAAI,MAAM,uBAAuB,YAAY;QAC3C,CAAA,GAAA,qLAAA,CAAA,WAAQ,AAAD,EAAE;IACX;IAEA,qBACE,8OAAC,yHAAA,CAAA,OAAI;QACH,cAAa;QACb,WAAU;;0BAEV,8OAAC,yHAAA,CAAA,WAAQ;gBAAC,WAAU;;kCAClB,8OAAC,yHAAA,CAAA,cAAW;wBACV,OAAM;wBACN,WAAU;;0CAEV,8OAAC,kNAAA,CAAA,aAAU;gCAAC,WAAU;;;;;;0CACtB,8OAAC;0CAAK;;;;;;;;;;;;kCAER,8OAAC,yHAAA,CAAA,cAAW;wBACV,OAAM;wBACN,WAAU;;0CAEV,8OAAC,0MAAA,CAAA,WAAQ;gCAAC,WAAU;;;;;;0CACpB,8OAAC;0CAAK;;;;;;;;;;;;kCAER,8OAAC,yHAAA,CAAA,cAAW;wBACV,OAAM;wBACN,WAAU;;0CAEV,8OAAC,oMAAA,CAAA,QAAK;gCAAC,WAAU;;;;;;0CACjB,8OAAC;0CAAK;;;;;;;;;;;;;;;;;;0BAGV,8OAAC;gBAAI,WAAU;;kCACb,8OAAC,yHAAA,CAAA,cAAW;wBAAC,OAAM;wBAAe,WAAU;kCAC1C,cAAA,8OAAC,iKAAA,CAAA,UAAsB;4BACrB,cAAc,iBAAiB,YAAY,IAAI,EAAE;;;;;;;;;;;kCAGrD,8OAAC,yHAAA,CAAA,cAAW;wBAAC,OAAM;wBAAe,WAAU;kCAC1C,cAAA,8OAAC,qKAAA,CAAA,uBAAoB;4BAAC,OAAO,iBAAiB,KAAK,IAAI,EAAE;;;;;;;;;;;kCAE3D,8OAAC,yHAAA,CAAA,cAAW;wBAAC,OAAM;wBAAW,WAAU;kCACtC,cAAA,8OAAC,+JAAA,CAAA,iBAAc;4BACb,UAAU,aAAa,QAAQ,IAAI,CAAC;4BACpC,SAAS,YAAY,OAAO,IAAI,EAAE;;;;;;;;;;;;;;;;;;;;;;;AAM9C","debugId":null}}]
}