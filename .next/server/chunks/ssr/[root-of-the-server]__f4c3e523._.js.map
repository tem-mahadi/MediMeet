{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/actions/appointments.js"],"sourcesContent":["\"use server\";\n\nimport { db } from \"@/lib/prisma\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { revalidatePath } from \"next/cache\";\n// deductCreditsForAppointment handled inside booking transaction to avoid race conditions\nimport { Vonage } from \"@vonage/server-sdk\";\nimport { addDays, addMinutes, format, isBefore, endOfDay } from \"date-fns\";\nimport { Auth } from \"@vonage/auth\";\n\n// Initialize Vonage Video API client\nconst credentials = new Auth({\n  applicationId: process.env.NEXT_PUBLIC_VONAGE_APPLICATION_ID,\n  privateKey: process.env.VONAGE_PRIVATE_KEY,\n});\nconst options = {};\nconst vonage = new Vonage(credentials, options);\n\n/**\n * Book a new appointment with a doctor\n */\nexport async function bookAppointment(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    // Get the patient user\n    const patient = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"PATIENT\",\n      },\n    });\n\n    if (!patient) {\n      throw new Error(\"Patient not found\");\n    }\n\n    // Parse form data\n    const doctorId = formData.get(\"doctorId\");\n    const startTime = new Date(formData.get(\"startTime\"));\n    const endTime = new Date(formData.get(\"endTime\"));\n    const patientDescription = formData.get(\"description\") || null;\n\n    // Validate input\n    if (!doctorId || !startTime || !endTime) {\n      throw new Error(\"Doctor, start time, and end time are required\");\n    }\n\n    // Check if the doctor exists and is verified\n    const doctor = await db.user.findUnique({\n      where: {\n        id: doctorId,\n        role: \"DOCTOR\",\n        verificationStatus: \"VERIFIED\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found or not verified\");\n    }\n\n    // Check if the patient has enough credits (2 credits per appointment)\n    if (patient.credits < 2) {\n      throw new Error(\"Insufficient credits to book an appointment\");\n    }\n\n    // Create a new Vonage Video API session (do this before DB tx)\n    const sessionId = await createVideoSession();\n\n    // Perform overlap checks, credit transfer and appointment creation inside a single serializable transaction\n    const appointment = await db.$transaction(\n      async (tx) => {\n        // Re-fetch patient and doctor inside transaction to ensure up-to-date values\n        const txPatient = await tx.user.findUnique({ where: { id: patient.id } });\n        const txDoctor = await tx.user.findUnique({ where: { id: doctor.id } });\n\n        if (!txPatient) throw new Error(\"Patient not found (tx)\");\n        if (!txDoctor) throw new Error(\"Doctor not found (tx)\");\n\n        // Check overlapping appointments for doctor\n        const overlappingForDoctor = await tx.appointment.findFirst({\n          where: {\n            doctorId: doctorId,\n            status: \"SCHEDULED\",\n            OR: [\n              {\n                startTime: { lte: startTime },\n                endTime: { gt: startTime },\n              },\n              {\n                startTime: { lt: endTime },\n                endTime: { gte: endTime },\n              },\n              {\n                startTime: { gte: startTime },\n                endTime: { lte: endTime },\n              },\n            ],\n          },\n        });\n\n        if (overlappingForDoctor) {\n          throw new Error(\"This time slot is already booked for the doctor\");\n        }\n\n        // Check overlapping appointments for patient (prevent patient booking multiple at same time)\n        const overlappingForPatient = await tx.appointment.findFirst({\n          where: {\n            patientId: txPatient.id,\n            status: \"SCHEDULED\",\n            OR: [\n              {\n                startTime: { lte: startTime },\n                endTime: { gt: startTime },\n              },\n              {\n                startTime: { lt: endTime },\n                endTime: { gte: endTime },\n              },\n              {\n                startTime: { gte: startTime },\n                endTime: { lte: endTime },\n              },\n            ],\n          },\n        });\n\n        if (overlappingForPatient) {\n          throw new Error(\"You already have an appointment at this time\");\n        }\n\n        // Ensure patient has sufficient credits inside transaction\n        if (txPatient.credits < 2) {\n          throw new Error(\"Insufficient credits to book an appointment\");\n        }\n\n        // Create credit transactions and update balances\n        await tx.creditTransaction.create({\n          data: {\n            userId: txPatient.id,\n            amount: -2,\n            type: \"APPOINTMENT_DEDUCTION\",\n          },\n        });\n\n        await tx.creditTransaction.create({\n          data: {\n            userId: txDoctor.id,\n            amount: 2,\n            type: \"APPOINTMENT_DEDUCTION\",\n          },\n        });\n\n        await tx.user.update({\n          where: { id: txPatient.id },\n          data: { credits: { decrement: 2 } },\n        });\n\n        await tx.user.update({\n          where: { id: txDoctor.id },\n          data: { credits: { increment: 2 } },\n        });\n\n        // Create the appointment\n        const created = await tx.appointment.create({\n          data: {\n            patientId: txPatient.id,\n            doctorId: txDoctor.id,\n            startTime,\n            endTime,\n            patientDescription,\n            status: \"SCHEDULED\",\n            videoSessionId: sessionId,\n          },\n        });\n\n        return created;\n      },\n      { isolationLevel: \"Serializable\" }\n    );\n\n  revalidatePath(\"/appointments\");\n  revalidatePath(\"/doctor\");\n  return { success: true, appointment: appointment };\n  } catch (error) {\n    console.error(\"Failed to book appointment:\", error);\n    throw new Error(\"Failed to book appointment:\" + error.message);\n  }\n}\n\n/**\n * Generate a Vonage Video API session\n */\nasync function createVideoSession() {\n  try {\n    const session = await vonage.video.createSession({ mediaMode: \"routed\" });\n    return session.sessionId;\n  } catch (error) {\n    throw new Error(\"Failed to create video session: \" + error.message);\n  }\n}\n\n/**\n * Generate a token for a video session\n * This will be called when either doctor or patient is about to join the call\n */\nexport async function generateVideoToken(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const user = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n      },\n    });\n\n    if (!user) {\n      throw new Error(\"User not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n\n    if (!appointmentId) {\n      throw new Error(\"Appointment ID is required\");\n    }\n\n    // Find the appointment and verify the user is part of it\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found\");\n    }\n\n    // Verify the user is either the doctor or the patient for this appointment\n    if (appointment.doctorId !== user.id && appointment.patientId !== user.id) {\n      throw new Error(\"You are not authorized to join this call\");\n    }\n\n    // Verify the appointment is scheduled\n    if (appointment.status !== \"SCHEDULED\") {\n      throw new Error(\"This appointment is not currently scheduled\");\n    }\n\n    // Verify the appointment is within a valid time range (e.g., starting 5 minutes before scheduled time)\n    const now = new Date();\n    const appointmentTime = new Date(appointment.startTime);\n    const timeDifference = (appointmentTime - now) / (1000 * 60); // difference in minutes\n\n    if (timeDifference > 30) {\n      throw new Error(\n        \"The call will be available 30 minutes before the scheduled time\"\n      );\n    }\n\n    // Generate a token for the video session\n    // Token expires 2 hours after the appointment start time\n    const appointmentEndTime = new Date(appointment.endTime);\n    const expirationTime =\n      Math.floor(appointmentEndTime.getTime() / 1000) + 60 * 60; // 1 hour after end time\n\n    // Use user's name and role as connection data\n    const connectionData = JSON.stringify({\n      name: user.name,\n      role: user.role,\n      userId: user.id,\n    });\n\n    // Generate the token with appropriate role and expiration\n    const token = vonage.video.generateClientToken(appointment.videoSessionId, {\n      role: \"publisher\", // Both doctor and patient can publish streams\n      expireTime: expirationTime,\n      data: connectionData,\n    });\n\n    // Update the appointment with the token\n    await db.appointment.update({\n      where: {\n        id: appointmentId,\n      },\n      data: {\n        videoSessionToken: token,\n      },\n    });\n\n    return {\n      success: true,\n      videoSessionId: appointment.videoSessionId,\n      token: token,\n    };\n  } catch (error) {\n    console.error(\"Failed to generate video token:\", error);\n    throw new Error(\"Failed to generate video token:\" + error.message);\n  }\n}\n\n/**\n * Get doctor by ID\n */\nexport async function getDoctorById(doctorId) {\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        id: doctorId,\n        role: \"DOCTOR\",\n        verificationStatus: \"VERIFIED\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    return { doctor };\n  } catch (error) {\n    console.error(\"Failed to fetch doctor:\", error);\n    throw new Error(\"Failed to fetch doctor details\");\n  }\n}\n\n/**\n * Get available time slots for booking for the next 4 days\n */\nexport async function getAvailableTimeSlots(doctorId) {\n  try {\n    // Validate doctor existence and verification\n    const doctor = await db.user.findUnique({\n      where: {\n        id: doctorId,\n        role: \"DOCTOR\",\n        verificationStatus: \"VERIFIED\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found or not verified\");\n    }\n\n    // Fetch a single availability record\n    const availability = await db.availability.findFirst({\n      where: {\n        doctorId: doctor.id,\n        status: \"AVAILABLE\",\n      },\n    });\n\n    if (!availability) {\n      throw new Error(\"No availability set by doctor\");\n    }\n\n    // Get the next 4 days\n    const now = new Date();\n    const days = [now, addDays(now, 1), addDays(now, 2), addDays(now, 3)];\n\n    // Fetch existing appointments for the doctor over the next 4 days\n    const lastDay = endOfDay(days[3]);\n    const existingAppointments = await db.appointment.findMany({\n      where: {\n        doctorId: doctor.id,\n        status: \"SCHEDULED\",\n        startTime: {\n          lte: lastDay,\n        },\n      },\n    });\n\n    const availableSlotsByDay = {};\n\n    // For each of the next 4 days, generate available slots\n    for (const day of days) {\n      const dayString = format(day, \"yyyy-MM-dd\");\n      availableSlotsByDay[dayString] = [];\n\n      // Create a copy of the availability start/end times for this day\n      const availabilityStart = new Date(availability.startTime);\n      const availabilityEnd = new Date(availability.endTime);\n\n      // Set the day to the current day we're processing\n      availabilityStart.setFullYear(\n        day.getFullYear(),\n        day.getMonth(),\n        day.getDate()\n      );\n      availabilityEnd.setFullYear(\n        day.getFullYear(),\n        day.getMonth(),\n        day.getDate()\n      );\n\n      let current = new Date(availabilityStart);\n      const end = new Date(availabilityEnd);\n\n      while (\n        isBefore(addMinutes(current, 30), end) ||\n        +addMinutes(current, 30) === +end\n      ) {\n        const next = addMinutes(current, 30);\n\n        // Skip past slots\n        if (isBefore(current, now)) {\n          current = next;\n          continue;\n        }\n\n        const overlaps = existingAppointments.some((appointment) => {\n          const aStart = new Date(appointment.startTime);\n          const aEnd = new Date(appointment.endTime);\n\n          return (\n            (current >= aStart && current < aEnd) ||\n            (next > aStart && next <= aEnd) ||\n            (current <= aStart && next >= aEnd)\n          );\n        });\n\n        if (!overlaps) {\n          availableSlotsByDay[dayString].push({\n            startTime: current.toISOString(),\n            endTime: next.toISOString(),\n            formatted: `${format(current, \"h:mm a\")} - ${format(\n              next,\n              \"h:mm a\"\n            )}`,\n            day: format(current, \"EEEE, MMMM d\"),\n          });\n        }\n\n        current = next;\n      }\n    }\n\n    // Convert to array of slots grouped by day for easier consumption by the UI\n    const result = Object.entries(availableSlotsByDay).map(([date, slots]) => ({\n      date,\n      displayDate:\n        slots.length > 0\n          ? slots[0].day\n          : format(new Date(date), \"EEEE, MMMM d\"),\n      slots,\n    }));\n\n    return { days: result };\n  } catch (error) {\n    console.error(\"Failed to fetch available slots:\", error);\n    throw new Error(\"Failed to fetch available time slots: \" + error.message);\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 551, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/components/page-header.jsx"],"sourcesContent":["import Link from \"next/link\";\nimport { ArrowLeft } from \"lucide-react\";\nimport React from \"react\";\nimport { Button } from \"./ui/button\";\n\n/**\n * Reusable page header component with back button and title\n *\n * @param {React.ReactNode} props.icon - Icon component to display next to the title\n * @param {string} props.title - Page title\n * @param {string} props.backLink - URL to navigate back to (defaults to home)\n * @param {string} props.backLabel - Text for the back link (defaults to \"Back to Home\")\n */\nexport function PageHeader({\n  icon,\n  title,\n  backLink = \"/\",\n  backLabel = \"Back to Home\",\n}) {\n  return (\n    <div className=\"flex flex-col justify-between gap-5 mb-8\">\n      <Link href={backLink}>\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          className=\"mb-2 border-emerald-900/30\"\n        >\n          <ArrowLeft className=\"h-4 w-4 mr-2\" />\n          {backLabel}\n        </Button>\n      </Link>\n      <div className=\"flex items-end gap-2\">\n        {icon && (\n          <div className=\"text-emerald-400\">\n            {React.cloneElement(icon, {\n              className: \"h-12 md:h-14 w-12 md:w-14\",\n            })}\n          </div>\n        )}\n        <h1 className=\"text-4xl md:text-5xl gradient-title\">{title}</h1>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;;AAUO,SAAS,WAAW,EACzB,IAAI,EACJ,KAAK,EACL,WAAW,GAAG,EACd,YAAY,cAAc,EAC3B;IACC,qBACE,8OAAC;QAAI,WAAU;;0BACb,8OAAC,4JAAA,CAAA,UAAI;gBAAC,MAAM;0BACV,cAAA,8OAAC,2HAAA,CAAA,SAAM;oBACL,SAAQ;oBACR,MAAK;oBACL,WAAU;;sCAEV,8OAAC,gNAAA,CAAA,YAAS;4BAAC,WAAU;;;;;;wBACpB;;;;;;;;;;;;0BAGL,8OAAC;gBAAI,WAAU;;oBACZ,sBACC,8OAAC;wBAAI,WAAU;kCACZ,cAAA,qMAAA,CAAA,UAAK,CAAC,YAAY,CAAC,MAAM;4BACxB,WAAW;wBACb;;;;;;kCAGJ,8OAAC;wBAAG,WAAU;kCAAuC;;;;;;;;;;;;;;;;;;AAI7D","debugId":null}},
    {"offset": {"line": 634, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/app/%28main%29/doctors/%5Bspecialty%5D/%5Bid%5D/layout.js"],"sourcesContent":["import { getDoctorById } from \"@/actions/appointments\";\nimport { redirect } from \"next/navigation\";\nimport { PageHeader } from \"@/components/page-header\";\n\nexport async function generateMetadata({ params }) {\n  const { id } = await params;\n\n  const { doctor } = await getDoctorById(id);\n  return {\n    title: `Dr. ${doctor.name} - MediMeet`,\n    description: `Book an appointment with Dr. ${doctor.name}, ${doctor.specialty} specialist with ${doctor.experience} years of experience.`,\n  };\n}\n\nexport default async function DoctorProfileLayout({ children, params }) {\n  const { id } = await params;\n  const { doctor } = await getDoctorById(id);\n\n  if (!doctor) redirect(\"/doctors\");\n\n  return (\n    <div className=\"container mx-auto\">\n      <PageHeader\n        // icon={<Stethoscope />}\n        title={\"Dr. \" + doctor.name}\n        backLink={`/doctors/${doctor.specialty}`}\n        backLabel={`Back to ${doctor.specialty}`}\n      />\n\n      {children}\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;AAAA;AACA;;;;;AAEO,eAAe,iBAAiB,EAAE,MAAM,EAAE;IAC/C,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;IAErB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,uHAAA,CAAA,gBAAa,AAAD,EAAE;IACvC,OAAO;QACL,OAAO,CAAC,IAAI,EAAE,OAAO,IAAI,CAAC,WAAW,CAAC;QACtC,aAAa,CAAC,6BAA6B,EAAE,OAAO,IAAI,CAAC,EAAE,EAAE,OAAO,SAAS,CAAC,iBAAiB,EAAE,OAAO,UAAU,CAAC,qBAAqB,CAAC;IAC3I;AACF;AAEe,eAAe,oBAAoB,EAAE,QAAQ,EAAE,MAAM,EAAE;IACpE,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;IACrB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,uHAAA,CAAA,gBAAa,AAAD,EAAE;IAEvC,IAAI,CAAC,QAAQ,CAAA,GAAA,qLAAA,CAAA,WAAQ,AAAD,EAAE;IAEtB,qBACE,8OAAC;QAAI,WAAU;;0BACb,8OAAC,6HAAA,CAAA,aAAU;gBACT,yBAAyB;gBACzB,OAAO,SAAS,OAAO,IAAI;gBAC3B,UAAU,CAAC,SAAS,EAAE,OAAO,SAAS,EAAE;gBACxC,WAAW,CAAC,QAAQ,EAAE,OAAO,SAAS,EAAE;;;;;;YAGzC;;;;;;;AAGP","debugId":null}}]
}