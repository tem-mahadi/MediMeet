{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/lib/utils.js"],"sourcesContent":["import { clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs) {\n  return twMerge(clsx(inputs));\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAM;IAC1B,OAAO,CAAA,GAAA,8JAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,wIAAA,CAAA,OAAI,AAAD,EAAE;AACtB","debugId":null}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/components/ui/card.jsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Card({\n  className,\n  ...props\n}) {\n  return (\n    <div\n      data-slot=\"card\"\n      className={cn(\n        \"bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm\",\n        className\n      )}\n      {...props} />\n  );\n}\n\nfunction CardHeader({\n  className,\n  ...props\n}) {\n  return (\n    <div\n      data-slot=\"card-header\"\n      className={cn(\n        \"@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6\",\n        className\n      )}\n      {...props} />\n  );\n}\n\nfunction CardTitle({\n  className,\n  ...props\n}) {\n  return (\n    <div\n      data-slot=\"card-title\"\n      className={cn(\"leading-none font-semibold\", className)}\n      {...props} />\n  );\n}\n\nfunction CardDescription({\n  className,\n  ...props\n}) {\n  return (\n    <div\n      data-slot=\"card-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props} />\n  );\n}\n\nfunction CardAction({\n  className,\n  ...props\n}) {\n  return (\n    <div\n      data-slot=\"card-action\"\n      className={cn(\n        \"col-start-2 row-span-2 row-start-1 self-start justify-self-end\",\n        className\n      )}\n      {...props} />\n  );\n}\n\nfunction CardContent({\n  className,\n  ...props\n}) {\n  return (<div data-slot=\"card-content\" className={cn(\"px-6\", className)} {...props} />);\n}\n\nfunction CardFooter({\n  className,\n  ...props\n}) {\n  return (\n    <div\n      data-slot=\"card-footer\"\n      className={cn(\"flex items-center px-6 [.border-t]:pt-6\", className)}\n      {...props} />\n  );\n}\n\nexport {\n  Card,\n  CardHeader,\n  CardFooter,\n  CardTitle,\n  CardAction,\n  CardDescription,\n  CardContent,\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAEA;;;;AAEA,SAAS,KAAK,EACZ,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EACV,qFACA;QAED,GAAG,KAAK;;;;;;AAEf;KAbS;AAeT,SAAS,WAAW,EAClB,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EACV,8JACA;QAED,GAAG,KAAK;;;;;;AAEf;MAbS;AAeT,SAAS,UAAU,EACjB,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EAAE,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAEf;MAVS;AAYT,SAAS,gBAAgB,EACvB,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAEf;MAVS;AAYT,SAAS,WAAW,EAClB,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EACV,kEACA;QAED,GAAG,KAAK;;;;;;AAEf;MAbS;AAeT,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACJ;IACC,qBAAQ,6LAAC;QAAI,aAAU;QAAe,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EAAE,QAAQ;QAAa,GAAG,KAAK;;;;;;AACnF;MALS;AAOT,SAAS,WAAW,EAClB,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EAAE,2CAA2C;QACxD,GAAG,KAAK;;;;;;AAEf;MAVS","debugId":null}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/components/ui/button.jsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva } from \"class-variance-authority\";\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground shadow-xs hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  ...props\n}) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props} />\n  );\n}\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,iBAAiB,CAAA,GAAA,mKAAA,CAAA,MAAG,AAAD,EACvB,+bACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,aACE;YACF,SACE;YACF,WACE;YACF,OACE;YACF,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;QACR;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AAGF,SAAS,OAAO,EACd,SAAS,EACT,OAAO,EACP,IAAI,EACJ,UAAU,KAAK,EACf,GAAG,OACJ;IACC,MAAM,OAAO,UAAU,mKAAA,CAAA,OAAI,GAAG;IAE9B,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EAAE,eAAe;YAAE;YAAS;YAAM;QAAU;QACvD,GAAG,KAAK;;;;;;AAEf;KAfS","debugId":null}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/components/ui/textarea.jsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Textarea({\n  className,\n  ...props\n}) {\n  return (\n    <textarea\n      data-slot=\"textarea\"\n      className={cn(\n        \"border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      {...props} />\n  );\n}\n\nexport { Textarea }\n"],"names":[],"mappings":";;;;AAAA;AAEA;;;;AAEA,SAAS,SAAS,EAChB,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EACV,ucACA;QAED,GAAG,KAAK;;;;;;AAEf;KAbS","debugId":null}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/components/ui/badge.jsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva } from \"class-variance-authority\";\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90\",\n        destructive:\n          \"border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nfunction Badge({\n  className,\n  variant,\n  asChild = false,\n  ...props\n}) {\n  const Comp = asChild ? Slot : \"span\"\n\n  return (\n    <Comp\n      data-slot=\"badge\"\n      className={cn(badgeVariants({ variant }), className)}\n      {...props} />\n  );\n}\n\nexport { Badge, badgeVariants }\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,gBAAgB,CAAA,GAAA,mKAAA,CAAA,MAAG,AAAD,EACtB,kZACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAGF,SAAS,MAAM,EACb,SAAS,EACT,OAAO,EACP,UAAU,KAAK,EACf,GAAG,OACJ;IACC,MAAM,OAAO,UAAU,mKAAA,CAAA,OAAI,GAAG;IAE9B,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EAAE,cAAc;YAAE;QAAQ,IAAI;QACzC,GAAG,KAAK;;;;;;AAEf;KAdS","debugId":null}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/components/ui/dialog.jsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { XIcon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Dialog({\n  ...props\n}) {\n  return <DialogPrimitive.Root data-slot=\"dialog\" {...props} />;\n}\n\nfunction DialogTrigger({\n  ...props\n}) {\n  return <DialogPrimitive.Trigger data-slot=\"dialog-trigger\" {...props} />;\n}\n\nfunction DialogPortal({\n  ...props\n}) {\n  return <DialogPrimitive.Portal data-slot=\"dialog-portal\" {...props} />;\n}\n\nfunction DialogClose({\n  ...props\n}) {\n  return <DialogPrimitive.Close data-slot=\"dialog-close\" {...props} />;\n}\n\nfunction DialogOverlay({\n  className,\n  ...props\n}) {\n  return (\n    <DialogPrimitive.Overlay\n      data-slot=\"dialog-overlay\"\n      className={cn(\n        \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50\",\n        className\n      )}\n      {...props} />\n  );\n}\n\nfunction DialogContent({\n  className,\n  children,\n  showCloseButton = true,\n  ...props\n}) {\n  return (\n    <DialogPortal data-slot=\"dialog-portal\">\n      <DialogOverlay />\n      <DialogPrimitive.Content\n        data-slot=\"dialog-content\"\n        className={cn(\n          \"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg\",\n          className\n        )}\n        {...props}>\n        {children}\n        {showCloseButton && (\n          <DialogPrimitive.Close\n            data-slot=\"dialog-close\"\n            className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\">\n            <XIcon />\n            <span className=\"sr-only\">Close</span>\n          </DialogPrimitive.Close>\n        )}\n      </DialogPrimitive.Content>\n    </DialogPortal>\n  );\n}\n\nfunction DialogHeader({\n  className,\n  ...props\n}) {\n  return (\n    <div\n      data-slot=\"dialog-header\"\n      className={cn(\"flex flex-col gap-2 text-center sm:text-left\", className)}\n      {...props} />\n  );\n}\n\nfunction DialogFooter({\n  className,\n  ...props\n}) {\n  return (\n    <div\n      data-slot=\"dialog-footer\"\n      className={cn(\"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end\", className)}\n      {...props} />\n  );\n}\n\nfunction DialogTitle({\n  className,\n  ...props\n}) {\n  return (\n    <DialogPrimitive.Title\n      data-slot=\"dialog-title\"\n      className={cn(\"text-lg leading-none font-semibold\", className)}\n      {...props} />\n  );\n}\n\nfunction DialogDescription({\n  className,\n  ...props\n}) {\n  return (\n    <DialogPrimitive.Description\n      data-slot=\"dialog-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props} />\n  );\n}\n\nexport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogOverlay,\n  DialogPortal,\n  DialogTitle,\n  DialogTrigger,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,SAAS,OAAO,EACd,GAAG,OACJ;IACC,qBAAO,6LAAC,qKAAA,CAAA,OAAoB;QAAC,aAAU;QAAU,GAAG,KAAK;;;;;;AAC3D;KAJS;AAMT,SAAS,cAAc,EACrB,GAAG,OACJ;IACC,qBAAO,6LAAC,qKAAA,CAAA,UAAuB;QAAC,aAAU;QAAkB,GAAG,KAAK;;;;;;AACtE;MAJS;AAMT,SAAS,aAAa,EACpB,GAAG,OACJ;IACC,qBAAO,6LAAC,qKAAA,CAAA,SAAsB;QAAC,aAAU;QAAiB,GAAG,KAAK;;;;;;AACpE;MAJS;AAMT,SAAS,YAAY,EACnB,GAAG,OACJ;IACC,qBAAO,6LAAC,qKAAA,CAAA,QAAqB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AAClE;MAJS;AAMT,SAAS,cAAc,EACrB,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC,qKAAA,CAAA,UAAuB;QACtB,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EACV,0JACA;QAED,GAAG,KAAK;;;;;;AAEf;MAbS;AAeT,SAAS,cAAc,EACrB,SAAS,EACT,QAAQ,EACR,kBAAkB,IAAI,EACtB,GAAG,OACJ;IACC,qBACE,6LAAC;QAAa,aAAU;;0BACtB,6LAAC;;;;;0BACD,6LAAC,qKAAA,CAAA,UAAuB;gBACtB,aAAU;gBACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EACV,+WACA;gBAED,GAAG,KAAK;;oBACR;oBACA,iCACC,6LAAC,qKAAA,CAAA,QAAqB;wBACpB,aAAU;wBACV,WAAU;;0CACV,6LAAC,mMAAA,CAAA,QAAK;;;;;0CACN,6LAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;AAMtC;MA5BS;AA8BT,SAAS,aAAa,EACpB,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EAAE,gDAAgD;QAC7D,GAAG,KAAK;;;;;;AAEf;MAVS;AAYT,SAAS,aAAa,EACpB,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC;QACC,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EAAE,0DAA0D;QACvE,GAAG,KAAK;;;;;;AAEf;MAVS;AAYT,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC,qKAAA,CAAA,QAAqB;QACpB,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EAAE,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAEf;MAVS;AAYT,SAAS,kBAAkB,EACzB,SAAS,EACT,GAAG,OACJ;IACC,qBACE,6LAAC,qKAAA,CAAA,cAA2B;QAC1B,aAAU;QACV,WAAW,CAAA,GAAA,+GAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAEf;MAVS","debugId":null}},
    {"offset": {"line": 495, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/actions/doctor.js"],"sourcesContent":["\"use server\";\n\nimport { db } from \"@/lib/prisma\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { revalidatePath } from \"next/cache\";\n\n/**\n * Set doctor's availability slots\n */\nexport async function setAvailabilitySlots(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    // Get the doctor\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    // Get form data\n    const startTime = formData.get(\"startTime\");\n    const endTime = formData.get(\"endTime\");\n\n    // Validate input\n    if (!startTime || !endTime) {\n      throw new Error(\"Start time and end time are required\");\n    }\n\n    if (startTime >= endTime) {\n      throw new Error(\"Start time must be before end time\");\n    }\n\n    // Check if the doctor already has slots\n    const existingSlots = await db.availability.findMany({\n      where: {\n        doctorId: doctor.id,\n      },\n    });\n\n    // If slots exist, delete them all (we're replacing them)\n    if (existingSlots.length > 0) {\n      // Don't delete slots that already have appointments\n      const slotsWithNoAppointments = existingSlots.filter(\n        (slot) => !slot.appointment\n      );\n\n      if (slotsWithNoAppointments.length > 0) {\n        await db.availability.deleteMany({\n          where: {\n            id: {\n              in: slotsWithNoAppointments.map((slot) => slot.id),\n            },\n          },\n        });\n      }\n    }\n\n    // Create new availability slot\n    const newSlot = await db.availability.create({\n      data: {\n        doctorId: doctor.id,\n        startTime: new Date(startTime),\n        endTime: new Date(endTime),\n        status: \"AVAILABLE\",\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, slot: newSlot };\n  } catch (error) {\n    console.error(\"Failed to set availability slots:\", error);\n    throw new Error(\"Failed to set availability: \" + error.message);\n  }\n}\n\n/**\n * Get doctor's current availability slots\n */\nexport async function getDoctorAvailability() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const availabilitySlots = await db.availability.findMany({\n      where: {\n        doctorId: doctor.id,\n      },\n      orderBy: {\n        startTime: \"asc\",\n      },\n    });\n\n    return { slots: availabilitySlots };\n  } catch (error) {\n    throw new Error(\"Failed to fetch availability slots \" + error.message);\n  }\n}\n\n/**\n * Get doctor's upcoming appointments\n */\n\nexport async function getDoctorAppointments() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointments = await db.appointment.findMany({\n      where: {\n        doctorId: doctor.id,\n        status: {\n          in: [\"SCHEDULED\"],\n        },\n      },\n      include: {\n        patient: true,\n      },\n      orderBy: {\n        startTime: \"asc\",\n      },\n    });\n\n    return { appointments };\n  } catch (error) {\n    throw new Error(\"Failed to fetch appointments \" + error.message);\n  }\n}\n\n/**\n * Cancel an appointment (can be done by both doctor and patient)\n */\nexport async function cancelAppointment(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const user = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n      },\n    });\n\n    if (!user) {\n      throw new Error(\"User not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n\n    if (!appointmentId) {\n      throw new Error(\"Appointment ID is required\");\n    }\n\n    // Find the appointment with both patient and doctor details\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n      },\n      include: {\n        patient: true,\n        doctor: true,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found\");\n    }\n\n    // Verify the user is either the doctor or the patient for this appointment\n    if (appointment.doctorId !== user.id && appointment.patientId !== user.id) {\n      throw new Error(\"You are not authorized to cancel this appointment\");\n    }\n\n    // Perform cancellation in a transaction\n    await db.$transaction(async (tx) => {\n      // Update the appointment status to CANCELLED\n      await tx.appointment.update({\n        where: {\n          id: appointmentId,\n        },\n        data: {\n          status: \"CANCELLED\",\n        },\n      });\n\n      // Always refund credits to patient and deduct from doctor\n      // Create credit transaction for patient (refund)\n      await tx.creditTransaction.create({\n        data: {\n          userId: appointment.patientId,\n          amount: 2,\n          type: \"APPOINTMENT_DEDUCTION\",\n        },\n      });\n\n      // Create credit transaction for doctor (deduction)\n      await tx.creditTransaction.create({\n        data: {\n          userId: appointment.doctorId,\n          amount: -2,\n          type: \"APPOINTMENT_DEDUCTION\",\n        },\n      });\n\n      // Update patient's credit balance (increment)\n      await tx.user.update({\n        where: {\n          id: appointment.patientId,\n        },\n        data: {\n          credits: {\n            increment: 2,\n          },\n        },\n      });\n\n      // Update doctor's credit balance (decrement)\n      await tx.user.update({\n        where: {\n          id: appointment.doctorId,\n        },\n        data: {\n          credits: {\n            decrement: 2,\n          },\n        },\n      });\n    });\n\n    // Determine which path to revalidate based on user role\n    if (user.role === \"DOCTOR\") {\n      revalidatePath(\"/doctor\");\n    } else if (user.role === \"PATIENT\") {\n      revalidatePath(\"/appointments\");\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Failed to cancel appointment:\", error);\n    throw new Error(\"Failed to cancel appointment: \" + error.message);\n  }\n}\n\n/**\n * Add notes to an appointment\n */\nexport async function addAppointmentNotes(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n    const notes = formData.get(\"notes\");\n\n    if (!appointmentId || !notes) {\n      throw new Error(\"Appointment ID and notes are required\");\n    }\n\n    // Verify the appointment belongs to this doctor\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n        doctorId: doctor.id,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found\");\n    }\n\n    // Update the appointment notes\n    const updatedAppointment = await db.appointment.update({\n      where: {\n        id: appointmentId,\n      },\n      data: {\n        notes,\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, appointment: updatedAppointment };\n  } catch (error) {\n    console.error(\"Failed to add appointment notes:\", error);\n    throw new Error(\"Failed to update notes: \" + error.message);\n  }\n}\n\n/**\n * Mark an appointment as completed (only by doctor after end time)\n */\nexport async function markAppointmentCompleted(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n\n    if (!appointmentId) {\n      throw new Error(\"Appointment ID is required\");\n    }\n\n    // Find the appointment\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n        doctorId: doctor.id, // Ensure appointment belongs to this doctor\n      },\n      include: {\n        patient: true,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found or not authorized\");\n    }\n\n    // Check if appointment is currently scheduled\n    if (appointment.status !== \"SCHEDULED\") {\n      throw new Error(\"Only scheduled appointments can be marked as completed\");\n    }\n\n    // Check if current time is after the appointment end time\n    const now = new Date();\n    const appointmentEndTime = new Date(appointment.endTime);\n\n    if (now < appointmentEndTime) {\n      throw new Error(\n        \"Cannot mark appointment as completed before the scheduled end time\"\n      );\n    }\n\n    // Update the appointment status to COMPLETED\n    const updatedAppointment = await db.appointment.update({\n      where: {\n        id: appointmentId,\n      },\n      data: {\n        status: \"COMPLETED\",\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, appointment: updatedAppointment };\n  } catch (error) {\n    console.error(\"Failed to mark appointment as completed:\", error);\n    throw new Error(\n      \"Failed to mark appointment as completed: \" + error.message\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;IAyKsB,oBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 511, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/actions/doctor.js"],"sourcesContent":["\"use server\";\n\nimport { db } from \"@/lib/prisma\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { revalidatePath } from \"next/cache\";\n\n/**\n * Set doctor's availability slots\n */\nexport async function setAvailabilitySlots(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    // Get the doctor\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    // Get form data\n    const startTime = formData.get(\"startTime\");\n    const endTime = formData.get(\"endTime\");\n\n    // Validate input\n    if (!startTime || !endTime) {\n      throw new Error(\"Start time and end time are required\");\n    }\n\n    if (startTime >= endTime) {\n      throw new Error(\"Start time must be before end time\");\n    }\n\n    // Check if the doctor already has slots\n    const existingSlots = await db.availability.findMany({\n      where: {\n        doctorId: doctor.id,\n      },\n    });\n\n    // If slots exist, delete them all (we're replacing them)\n    if (existingSlots.length > 0) {\n      // Don't delete slots that already have appointments\n      const slotsWithNoAppointments = existingSlots.filter(\n        (slot) => !slot.appointment\n      );\n\n      if (slotsWithNoAppointments.length > 0) {\n        await db.availability.deleteMany({\n          where: {\n            id: {\n              in: slotsWithNoAppointments.map((slot) => slot.id),\n            },\n          },\n        });\n      }\n    }\n\n    // Create new availability slot\n    const newSlot = await db.availability.create({\n      data: {\n        doctorId: doctor.id,\n        startTime: new Date(startTime),\n        endTime: new Date(endTime),\n        status: \"AVAILABLE\",\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, slot: newSlot };\n  } catch (error) {\n    console.error(\"Failed to set availability slots:\", error);\n    throw new Error(\"Failed to set availability: \" + error.message);\n  }\n}\n\n/**\n * Get doctor's current availability slots\n */\nexport async function getDoctorAvailability() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const availabilitySlots = await db.availability.findMany({\n      where: {\n        doctorId: doctor.id,\n      },\n      orderBy: {\n        startTime: \"asc\",\n      },\n    });\n\n    return { slots: availabilitySlots };\n  } catch (error) {\n    throw new Error(\"Failed to fetch availability slots \" + error.message);\n  }\n}\n\n/**\n * Get doctor's upcoming appointments\n */\n\nexport async function getDoctorAppointments() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointments = await db.appointment.findMany({\n      where: {\n        doctorId: doctor.id,\n        status: {\n          in: [\"SCHEDULED\"],\n        },\n      },\n      include: {\n        patient: true,\n      },\n      orderBy: {\n        startTime: \"asc\",\n      },\n    });\n\n    return { appointments };\n  } catch (error) {\n    throw new Error(\"Failed to fetch appointments \" + error.message);\n  }\n}\n\n/**\n * Cancel an appointment (can be done by both doctor and patient)\n */\nexport async function cancelAppointment(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const user = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n      },\n    });\n\n    if (!user) {\n      throw new Error(\"User not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n\n    if (!appointmentId) {\n      throw new Error(\"Appointment ID is required\");\n    }\n\n    // Find the appointment with both patient and doctor details\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n      },\n      include: {\n        patient: true,\n        doctor: true,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found\");\n    }\n\n    // Verify the user is either the doctor or the patient for this appointment\n    if (appointment.doctorId !== user.id && appointment.patientId !== user.id) {\n      throw new Error(\"You are not authorized to cancel this appointment\");\n    }\n\n    // Perform cancellation in a transaction\n    await db.$transaction(async (tx) => {\n      // Update the appointment status to CANCELLED\n      await tx.appointment.update({\n        where: {\n          id: appointmentId,\n        },\n        data: {\n          status: \"CANCELLED\",\n        },\n      });\n\n      // Always refund credits to patient and deduct from doctor\n      // Create credit transaction for patient (refund)\n      await tx.creditTransaction.create({\n        data: {\n          userId: appointment.patientId,\n          amount: 2,\n          type: \"APPOINTMENT_DEDUCTION\",\n        },\n      });\n\n      // Create credit transaction for doctor (deduction)\n      await tx.creditTransaction.create({\n        data: {\n          userId: appointment.doctorId,\n          amount: -2,\n          type: \"APPOINTMENT_DEDUCTION\",\n        },\n      });\n\n      // Update patient's credit balance (increment)\n      await tx.user.update({\n        where: {\n          id: appointment.patientId,\n        },\n        data: {\n          credits: {\n            increment: 2,\n          },\n        },\n      });\n\n      // Update doctor's credit balance (decrement)\n      await tx.user.update({\n        where: {\n          id: appointment.doctorId,\n        },\n        data: {\n          credits: {\n            decrement: 2,\n          },\n        },\n      });\n    });\n\n    // Determine which path to revalidate based on user role\n    if (user.role === \"DOCTOR\") {\n      revalidatePath(\"/doctor\");\n    } else if (user.role === \"PATIENT\") {\n      revalidatePath(\"/appointments\");\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Failed to cancel appointment:\", error);\n    throw new Error(\"Failed to cancel appointment: \" + error.message);\n  }\n}\n\n/**\n * Add notes to an appointment\n */\nexport async function addAppointmentNotes(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n    const notes = formData.get(\"notes\");\n\n    if (!appointmentId || !notes) {\n      throw new Error(\"Appointment ID and notes are required\");\n    }\n\n    // Verify the appointment belongs to this doctor\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n        doctorId: doctor.id,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found\");\n    }\n\n    // Update the appointment notes\n    const updatedAppointment = await db.appointment.update({\n      where: {\n        id: appointmentId,\n      },\n      data: {\n        notes,\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, appointment: updatedAppointment };\n  } catch (error) {\n    console.error(\"Failed to add appointment notes:\", error);\n    throw new Error(\"Failed to update notes: \" + error.message);\n  }\n}\n\n/**\n * Mark an appointment as completed (only by doctor after end time)\n */\nexport async function markAppointmentCompleted(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n\n    if (!appointmentId) {\n      throw new Error(\"Appointment ID is required\");\n    }\n\n    // Find the appointment\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n        doctorId: doctor.id, // Ensure appointment belongs to this doctor\n      },\n      include: {\n        patient: true,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found or not authorized\");\n    }\n\n    // Check if appointment is currently scheduled\n    if (appointment.status !== \"SCHEDULED\") {\n      throw new Error(\"Only scheduled appointments can be marked as completed\");\n    }\n\n    // Check if current time is after the appointment end time\n    const now = new Date();\n    const appointmentEndTime = new Date(appointment.endTime);\n\n    if (now < appointmentEndTime) {\n      throw new Error(\n        \"Cannot mark appointment as completed before the scheduled end time\"\n      );\n    }\n\n    // Update the appointment status to COMPLETED\n    const updatedAppointment = await db.appointment.update({\n      where: {\n        id: appointmentId,\n      },\n      data: {\n        status: \"COMPLETED\",\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, appointment: updatedAppointment };\n  } catch (error) {\n    console.error(\"Failed to mark appointment as completed:\", error);\n    throw new Error(\n      \"Failed to mark appointment as completed: \" + error.message\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;IA8RsB,sBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 527, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/actions/doctor.js"],"sourcesContent":["\"use server\";\n\nimport { db } from \"@/lib/prisma\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { revalidatePath } from \"next/cache\";\n\n/**\n * Set doctor's availability slots\n */\nexport async function setAvailabilitySlots(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    // Get the doctor\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    // Get form data\n    const startTime = formData.get(\"startTime\");\n    const endTime = formData.get(\"endTime\");\n\n    // Validate input\n    if (!startTime || !endTime) {\n      throw new Error(\"Start time and end time are required\");\n    }\n\n    if (startTime >= endTime) {\n      throw new Error(\"Start time must be before end time\");\n    }\n\n    // Check if the doctor already has slots\n    const existingSlots = await db.availability.findMany({\n      where: {\n        doctorId: doctor.id,\n      },\n    });\n\n    // If slots exist, delete them all (we're replacing them)\n    if (existingSlots.length > 0) {\n      // Don't delete slots that already have appointments\n      const slotsWithNoAppointments = existingSlots.filter(\n        (slot) => !slot.appointment\n      );\n\n      if (slotsWithNoAppointments.length > 0) {\n        await db.availability.deleteMany({\n          where: {\n            id: {\n              in: slotsWithNoAppointments.map((slot) => slot.id),\n            },\n          },\n        });\n      }\n    }\n\n    // Create new availability slot\n    const newSlot = await db.availability.create({\n      data: {\n        doctorId: doctor.id,\n        startTime: new Date(startTime),\n        endTime: new Date(endTime),\n        status: \"AVAILABLE\",\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, slot: newSlot };\n  } catch (error) {\n    console.error(\"Failed to set availability slots:\", error);\n    throw new Error(\"Failed to set availability: \" + error.message);\n  }\n}\n\n/**\n * Get doctor's current availability slots\n */\nexport async function getDoctorAvailability() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const availabilitySlots = await db.availability.findMany({\n      where: {\n        doctorId: doctor.id,\n      },\n      orderBy: {\n        startTime: \"asc\",\n      },\n    });\n\n    return { slots: availabilitySlots };\n  } catch (error) {\n    throw new Error(\"Failed to fetch availability slots \" + error.message);\n  }\n}\n\n/**\n * Get doctor's upcoming appointments\n */\n\nexport async function getDoctorAppointments() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointments = await db.appointment.findMany({\n      where: {\n        doctorId: doctor.id,\n        status: {\n          in: [\"SCHEDULED\"],\n        },\n      },\n      include: {\n        patient: true,\n      },\n      orderBy: {\n        startTime: \"asc\",\n      },\n    });\n\n    return { appointments };\n  } catch (error) {\n    throw new Error(\"Failed to fetch appointments \" + error.message);\n  }\n}\n\n/**\n * Cancel an appointment (can be done by both doctor and patient)\n */\nexport async function cancelAppointment(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const user = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n      },\n    });\n\n    if (!user) {\n      throw new Error(\"User not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n\n    if (!appointmentId) {\n      throw new Error(\"Appointment ID is required\");\n    }\n\n    // Find the appointment with both patient and doctor details\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n      },\n      include: {\n        patient: true,\n        doctor: true,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found\");\n    }\n\n    // Verify the user is either the doctor or the patient for this appointment\n    if (appointment.doctorId !== user.id && appointment.patientId !== user.id) {\n      throw new Error(\"You are not authorized to cancel this appointment\");\n    }\n\n    // Perform cancellation in a transaction\n    await db.$transaction(async (tx) => {\n      // Update the appointment status to CANCELLED\n      await tx.appointment.update({\n        where: {\n          id: appointmentId,\n        },\n        data: {\n          status: \"CANCELLED\",\n        },\n      });\n\n      // Always refund credits to patient and deduct from doctor\n      // Create credit transaction for patient (refund)\n      await tx.creditTransaction.create({\n        data: {\n          userId: appointment.patientId,\n          amount: 2,\n          type: \"APPOINTMENT_DEDUCTION\",\n        },\n      });\n\n      // Create credit transaction for doctor (deduction)\n      await tx.creditTransaction.create({\n        data: {\n          userId: appointment.doctorId,\n          amount: -2,\n          type: \"APPOINTMENT_DEDUCTION\",\n        },\n      });\n\n      // Update patient's credit balance (increment)\n      await tx.user.update({\n        where: {\n          id: appointment.patientId,\n        },\n        data: {\n          credits: {\n            increment: 2,\n          },\n        },\n      });\n\n      // Update doctor's credit balance (decrement)\n      await tx.user.update({\n        where: {\n          id: appointment.doctorId,\n        },\n        data: {\n          credits: {\n            decrement: 2,\n          },\n        },\n      });\n    });\n\n    // Determine which path to revalidate based on user role\n    if (user.role === \"DOCTOR\") {\n      revalidatePath(\"/doctor\");\n    } else if (user.role === \"PATIENT\") {\n      revalidatePath(\"/appointments\");\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Failed to cancel appointment:\", error);\n    throw new Error(\"Failed to cancel appointment: \" + error.message);\n  }\n}\n\n/**\n * Add notes to an appointment\n */\nexport async function addAppointmentNotes(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n    const notes = formData.get(\"notes\");\n\n    if (!appointmentId || !notes) {\n      throw new Error(\"Appointment ID and notes are required\");\n    }\n\n    // Verify the appointment belongs to this doctor\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n        doctorId: doctor.id,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found\");\n    }\n\n    // Update the appointment notes\n    const updatedAppointment = await db.appointment.update({\n      where: {\n        id: appointmentId,\n      },\n      data: {\n        notes,\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, appointment: updatedAppointment };\n  } catch (error) {\n    console.error(\"Failed to add appointment notes:\", error);\n    throw new Error(\"Failed to update notes: \" + error.message);\n  }\n}\n\n/**\n * Mark an appointment as completed (only by doctor after end time)\n */\nexport async function markAppointmentCompleted(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"DOCTOR\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n\n    if (!appointmentId) {\n      throw new Error(\"Appointment ID is required\");\n    }\n\n    // Find the appointment\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n        doctorId: doctor.id, // Ensure appointment belongs to this doctor\n      },\n      include: {\n        patient: true,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found or not authorized\");\n    }\n\n    // Check if appointment is currently scheduled\n    if (appointment.status !== \"SCHEDULED\") {\n      throw new Error(\"Only scheduled appointments can be marked as completed\");\n    }\n\n    // Check if current time is after the appointment end time\n    const now = new Date();\n    const appointmentEndTime = new Date(appointment.endTime);\n\n    if (now < appointmentEndTime) {\n      throw new Error(\n        \"Cannot mark appointment as completed before the scheduled end time\"\n      );\n    }\n\n    // Update the appointment status to COMPLETED\n    const updatedAppointment = await db.appointment.update({\n      where: {\n        id: appointmentId,\n      },\n      data: {\n        status: \"COMPLETED\",\n      },\n    });\n\n    revalidatePath(\"/doctor\");\n    return { success: true, appointment: updatedAppointment };\n  } catch (error) {\n    console.error(\"Failed to mark appointment as completed:\", error);\n    throw new Error(\n      \"Failed to mark appointment as completed: \" + error.message\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;IAyVsB,2BAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 543, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/actions/appointments.js"],"sourcesContent":["\"use server\";\n\nimport { db } from \"@/lib/prisma\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { revalidatePath } from \"next/cache\";\n// deductCreditsForAppointment handled inside booking transaction to avoid race conditions\nimport { Vonage } from \"@vonage/server-sdk\";\nimport { addDays, addMinutes, format, isBefore, endOfDay } from \"date-fns\";\nimport { Auth } from \"@vonage/auth\";\n\n// Initialize Vonage Video API client\nconst credentials = new Auth({\n  applicationId: process.env.NEXT_PUBLIC_VONAGE_APPLICATION_ID,\n  privateKey: process.env.VONAGE_PRIVATE_KEY,\n});\nconst options = {};\nconst vonage = new Vonage(credentials, options);\n\n/**\n * Book a new appointment with a doctor\n */\nexport async function bookAppointment(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    // Get the patient user\n    const patient = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n        role: \"PATIENT\",\n      },\n    });\n\n    if (!patient) {\n      throw new Error(\"Patient not found\");\n    }\n\n    // Parse form data\n    const doctorId = formData.get(\"doctorId\");\n    const startTime = new Date(formData.get(\"startTime\"));\n    const endTime = new Date(formData.get(\"endTime\"));\n    const patientDescription = formData.get(\"description\") || null;\n\n    // Validate input\n    if (!doctorId || !startTime || !endTime) {\n      throw new Error(\"Doctor, start time, and end time are required\");\n    }\n\n    // Check if the doctor exists and is verified\n    const doctor = await db.user.findUnique({\n      where: {\n        id: doctorId,\n        role: \"DOCTOR\",\n        verificationStatus: \"VERIFIED\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found or not verified\");\n    }\n\n    // Check if the patient has enough credits (2 credits per appointment)\n    if (patient.credits < 2) {\n      throw new Error(\"Insufficient credits to book an appointment\");\n    }\n\n    // Create a new Vonage Video API session (do this before DB tx)\n    const sessionId = await createVideoSession();\n\n    // Perform overlap checks, credit transfer and appointment creation inside a single serializable transaction\n    const appointment = await db.$transaction(\n      async (tx) => {\n        // Re-fetch patient and doctor inside transaction to ensure up-to-date values\n        const txPatient = await tx.user.findUnique({ where: { id: patient.id } });\n        const txDoctor = await tx.user.findUnique({ where: { id: doctor.id } });\n\n        if (!txPatient) throw new Error(\"Patient not found (tx)\");\n        if (!txDoctor) throw new Error(\"Doctor not found (tx)\");\n\n        // Check overlapping appointments for doctor\n        const overlappingForDoctor = await tx.appointment.findFirst({\n          where: {\n            doctorId: doctorId,\n            status: \"SCHEDULED\",\n            OR: [\n              {\n                startTime: { lte: startTime },\n                endTime: { gt: startTime },\n              },\n              {\n                startTime: { lt: endTime },\n                endTime: { gte: endTime },\n              },\n              {\n                startTime: { gte: startTime },\n                endTime: { lte: endTime },\n              },\n            ],\n          },\n        });\n\n        if (overlappingForDoctor) {\n          throw new Error(\"This time slot is already booked for the doctor\");\n        }\n\n        // Check overlapping appointments for patient (prevent patient booking multiple at same time)\n        const overlappingForPatient = await tx.appointment.findFirst({\n          where: {\n            patientId: txPatient.id,\n            status: \"SCHEDULED\",\n            OR: [\n              {\n                startTime: { lte: startTime },\n                endTime: { gt: startTime },\n              },\n              {\n                startTime: { lt: endTime },\n                endTime: { gte: endTime },\n              },\n              {\n                startTime: { gte: startTime },\n                endTime: { lte: endTime },\n              },\n            ],\n          },\n        });\n\n        if (overlappingForPatient) {\n          throw new Error(\"You already have an appointment at this time\");\n        }\n\n        // Ensure patient has sufficient credits inside transaction\n        if (txPatient.credits < 2) {\n          throw new Error(\"Insufficient credits to book an appointment\");\n        }\n\n        // Create credit transactions and update balances\n        await tx.creditTransaction.create({\n          data: {\n            userId: txPatient.id,\n            amount: -2,\n            type: \"APPOINTMENT_DEDUCTION\",\n          },\n        });\n\n        await tx.creditTransaction.create({\n          data: {\n            userId: txDoctor.id,\n            amount: 2,\n            type: \"APPOINTMENT_DEDUCTION\",\n          },\n        });\n\n        await tx.user.update({\n          where: { id: txPatient.id },\n          data: { credits: { decrement: 2 } },\n        });\n\n        await tx.user.update({\n          where: { id: txDoctor.id },\n          data: { credits: { increment: 2 } },\n        });\n\n        // Create the appointment\n        const created = await tx.appointment.create({\n          data: {\n            patientId: txPatient.id,\n            doctorId: txDoctor.id,\n            startTime,\n            endTime,\n            patientDescription,\n            status: \"SCHEDULED\",\n            videoSessionId: sessionId,\n          },\n        });\n\n        return created;\n      },\n      { isolationLevel: \"Serializable\" }\n    );\n\n  revalidatePath(\"/appointments\");\n  revalidatePath(\"/doctor\");\n  return { success: true, appointment: appointment };\n  } catch (error) {\n    console.error(\"Failed to book appointment:\", error);\n    throw new Error(\"Failed to book appointment:\" + error.message);\n  }\n}\n\n/**\n * Generate a Vonage Video API session\n */\nasync function createVideoSession() {\n  try {\n    const session = await vonage.video.createSession({ mediaMode: \"routed\" });\n    return session.sessionId;\n  } catch (error) {\n    throw new Error(\"Failed to create video session: \" + error.message);\n  }\n}\n\n/**\n * Generate a token for a video session\n * This will be called when either doctor or patient is about to join the call\n */\nexport async function generateVideoToken(formData) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  try {\n    const user = await db.user.findUnique({\n      where: {\n        clerkUserId: userId,\n      },\n    });\n\n    if (!user) {\n      throw new Error(\"User not found\");\n    }\n\n    const appointmentId = formData.get(\"appointmentId\");\n\n    if (!appointmentId) {\n      throw new Error(\"Appointment ID is required\");\n    }\n\n    // Find the appointment and verify the user is part of it\n    const appointment = await db.appointment.findUnique({\n      where: {\n        id: appointmentId,\n      },\n    });\n\n    if (!appointment) {\n      throw new Error(\"Appointment not found\");\n    }\n\n    // Verify the user is either the doctor or the patient for this appointment\n    if (appointment.doctorId !== user.id && appointment.patientId !== user.id) {\n      throw new Error(\"You are not authorized to join this call\");\n    }\n\n    // Verify the appointment is scheduled\n    if (appointment.status !== \"SCHEDULED\") {\n      throw new Error(\"This appointment is not currently scheduled\");\n    }\n\n    // Verify the appointment is within a valid time range (e.g., starting 5 minutes before scheduled time)\n    const now = new Date();\n    const appointmentTime = new Date(appointment.startTime);\n    const timeDifference = (appointmentTime - now) / (1000 * 60); // difference in minutes\n\n    if (timeDifference > 30) {\n      throw new Error(\n        \"The call will be available 30 minutes before the scheduled time\"\n      );\n    }\n\n    // Generate a token for the video session\n    // Token expires 2 hours after the appointment start time\n    const appointmentEndTime = new Date(appointment.endTime);\n    const expirationTime =\n      Math.floor(appointmentEndTime.getTime() / 1000) + 60 * 60; // 1 hour after end time\n\n    // Use user's name and role as connection data\n    const connectionData = JSON.stringify({\n      name: user.name,\n      role: user.role,\n      userId: user.id,\n    });\n\n    // Generate the token with appropriate role and expiration\n    const token = vonage.video.generateClientToken(appointment.videoSessionId, {\n      role: \"publisher\", // Both doctor and patient can publish streams\n      expireTime: expirationTime,\n      data: connectionData,\n    });\n\n    // Update the appointment with the token\n    await db.appointment.update({\n      where: {\n        id: appointmentId,\n      },\n      data: {\n        videoSessionToken: token,\n      },\n    });\n\n    return {\n      success: true,\n      videoSessionId: appointment.videoSessionId,\n      token: token,\n    };\n  } catch (error) {\n    console.error(\"Failed to generate video token:\", error);\n    throw new Error(\"Failed to generate video token:\" + error.message);\n  }\n}\n\n/**\n * Get doctor by ID\n */\nexport async function getDoctorById(doctorId) {\n  try {\n    const doctor = await db.user.findUnique({\n      where: {\n        id: doctorId,\n        role: \"DOCTOR\",\n        verificationStatus: \"VERIFIED\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found\");\n    }\n\n    return { doctor };\n  } catch (error) {\n    console.error(\"Failed to fetch doctor:\", error);\n    throw new Error(\"Failed to fetch doctor details\");\n  }\n}\n\n/**\n * Get available time slots for booking for the next 4 days\n */\nexport async function getAvailableTimeSlots(doctorId) {\n  try {\n    // Validate doctor existence and verification\n    const doctor = await db.user.findUnique({\n      where: {\n        id: doctorId,\n        role: \"DOCTOR\",\n        verificationStatus: \"VERIFIED\",\n      },\n    });\n\n    if (!doctor) {\n      throw new Error(\"Doctor not found or not verified\");\n    }\n\n    // Fetch a single availability record\n    const availability = await db.availability.findFirst({\n      where: {\n        doctorId: doctor.id,\n        status: \"AVAILABLE\",\n      },\n    });\n\n    if (!availability) {\n      throw new Error(\"No availability set by doctor\");\n    }\n\n    // Get the next 4 days\n    const now = new Date();\n    const days = [now, addDays(now, 1), addDays(now, 2), addDays(now, 3)];\n\n    // Fetch existing appointments for the doctor over the next 4 days\n    const lastDay = endOfDay(days[3]);\n    const existingAppointments = await db.appointment.findMany({\n      where: {\n        doctorId: doctor.id,\n        status: \"SCHEDULED\",\n        startTime: {\n          lte: lastDay,\n        },\n      },\n    });\n\n    const availableSlotsByDay = {};\n\n    // For each of the next 4 days, generate available slots\n    for (const day of days) {\n      const dayString = format(day, \"yyyy-MM-dd\");\n      availableSlotsByDay[dayString] = [];\n\n      // Create a copy of the availability start/end times for this day\n      const availabilityStart = new Date(availability.startTime);\n      const availabilityEnd = new Date(availability.endTime);\n\n      // Set the day to the current day we're processing\n      availabilityStart.setFullYear(\n        day.getFullYear(),\n        day.getMonth(),\n        day.getDate()\n      );\n      availabilityEnd.setFullYear(\n        day.getFullYear(),\n        day.getMonth(),\n        day.getDate()\n      );\n\n      let current = new Date(availabilityStart);\n      const end = new Date(availabilityEnd);\n\n      while (\n        isBefore(addMinutes(current, 30), end) ||\n        +addMinutes(current, 30) === +end\n      ) {\n        const next = addMinutes(current, 30);\n\n        // Skip past slots\n        if (isBefore(current, now)) {\n          current = next;\n          continue;\n        }\n\n        const overlaps = existingAppointments.some((appointment) => {\n          const aStart = new Date(appointment.startTime);\n          const aEnd = new Date(appointment.endTime);\n\n          return (\n            (current >= aStart && current < aEnd) ||\n            (next > aStart && next <= aEnd) ||\n            (current <= aStart && next >= aEnd)\n          );\n        });\n\n        if (!overlaps) {\n          availableSlotsByDay[dayString].push({\n            startTime: current.toISOString(),\n            endTime: next.toISOString(),\n            formatted: `${format(current, \"h:mm a\")} - ${format(\n              next,\n              \"h:mm a\"\n            )}`,\n            day: format(current, \"EEEE, MMMM d\"),\n          });\n        }\n\n        current = next;\n      }\n    }\n\n    // Convert to array of slots grouped by day for easier consumption by the UI\n    const result = Object.entries(availableSlotsByDay).map(([date, slots]) => ({\n      date,\n      displayDate:\n        slots.length > 0\n          ? slots[0].day\n          : format(new Date(date), \"EEEE, MMMM d\"),\n      slots,\n    }));\n\n    return { days: result };\n  } catch (error) {\n    console.error(\"Failed to fetch available slots:\", error);\n    throw new Error(\"Failed to fetch available time slots: \" + error.message);\n  }\n}\n"],"names":[],"mappings":";;;;;;IAkNsB,qBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 559, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/hooks/use-fetch.js"],"sourcesContent":["import { useState } from \"react\";\nimport { toast } from \"sonner\";\n\nconst useFetch = (cb) => {\n  const [data, setData] = useState(undefined);\n  const [loading, setLoading] = useState(null);\n  const [error, setError] = useState(null);\n\n  const fn = async (...args) => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const response = await cb(...args);\n      setData(response);\n      setError(null);\n    } catch (error) {\n      setError(error);\n      toast.error(error.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return { data, loading, error, fn, setData };\n};\n\nexport default useFetch;\n"],"names":[],"mappings":";;;AAAA;AACA;;;;AAEA,MAAM,WAAW,CAAC;;IAChB,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IACjC,MAAM,CAAC,SAAS,WAAW,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IACvC,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IAEnC,MAAM,KAAK,OAAO,GAAG;QACnB,WAAW;QACX,SAAS;QAET,IAAI;YACF,MAAM,WAAW,MAAM,MAAM;YAC7B,QAAQ;YACR,SAAS;QACX,EAAE,OAAO,OAAO;YACd,SAAS;YACT,2IAAA,CAAA,QAAK,CAAC,KAAK,CAAC,MAAM,OAAO;QAC3B,SAAU;YACR,WAAW;QACb;IACF;IAEA,OAAO;QAAE;QAAM;QAAS;QAAO;QAAI;IAAQ;AAC7C;GAtBM;uCAwBS","debugId":null}},
    {"offset": {"line": 605, "column": 0}, "map": {"version":3,"sources":["file:///Users/hasanalmahadi/WebProject/medimeet/components/appointment-card.jsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { format } from \"date-fns\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport {\n  Calendar,\n  Clock,\n  User,\n  Video,\n  Stethoscope,\n  X,\n  Edit,\n  Loader2,\n  CheckCircle,\n} from \"lucide-react\";\nimport { Badge } from \"@/components/ui/badge\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport {\n  cancelAppointment,\n  addAppointmentNotes,\n  markAppointmentCompleted,\n} from \"@/actions/doctor\";\nimport { generateVideoToken } from \"@/actions/appointments\";\nimport useFetch from \"@/hooks/use-fetch\";\nimport { toast } from \"sonner\";\nimport { useRouter } from \"next/navigation\";\n\nexport function AppointmentCard({\n  appointment,\n  userRole,\n  refetchAppointments,\n}) {\n  const [open, setOpen] = useState(false);\n  const [action, setAction] = useState(null); // 'cancel', 'notes', 'video', or 'complete'\n  const [notes, setNotes] = useState(appointment.notes || \"\");\n  const router = useRouter();\n\n  // UseFetch hooks for server actions\n  const {\n    loading: cancelLoading,\n    fn: submitCancel,\n    data: cancelData,\n  } = useFetch(cancelAppointment);\n  const {\n    loading: notesLoading,\n    fn: submitNotes,\n    data: notesData,\n  } = useFetch(addAppointmentNotes);\n  const {\n    loading: tokenLoading,\n    fn: submitTokenRequest,\n    data: tokenData,\n  } = useFetch(generateVideoToken);\n  const {\n    loading: completeLoading,\n    fn: submitMarkCompleted,\n    data: completeData,\n  } = useFetch(markAppointmentCompleted);\n\n  // Format date and time\n  const formatDateTime = (dateString) => {\n    try {\n      return format(new Date(dateString), \"MMMM d, yyyy 'at' h:mm a\");\n    } catch (e) {\n      return \"Invalid date\";\n    }\n  };\n\n  // Format time only\n  const formatTime = (dateString) => {\n    try {\n      return format(new Date(dateString), \"h:mm a\");\n    } catch (e) {\n      return \"Invalid time\";\n    }\n  };\n\n  // Check if appointment can be marked as completed\n  const canMarkCompleted = () => {\n    if (userRole !== \"DOCTOR\" || appointment.status !== \"SCHEDULED\") {\n      return false;\n    }\n    const now = new Date();\n    const appointmentEndTime = new Date(appointment.endTime);\n    return now >= appointmentEndTime;\n  };\n\n  // Handle cancel appointment\n  const handleCancelAppointment = async () => {\n    if (cancelLoading) return;\n\n    if (\n      window.confirm(\n        \"Are you sure you want to cancel this appointment? This action cannot be undone.\"\n      )\n    ) {\n      const formData = new FormData();\n      formData.append(\"appointmentId\", appointment.id);\n      await submitCancel(formData);\n    }\n  };\n\n  // Handle mark as completed\n  const handleMarkCompleted = async () => {\n    if (completeLoading) return;\n\n    // Check if appointment end time has passed\n    const now = new Date();\n    const appointmentEndTime = new Date(appointment.endTime);\n\n    if (now < appointmentEndTime) {\n      alert(\n        \"Cannot mark appointment as completed before the scheduled end time.\"\n      );\n      return;\n    }\n\n    if (\n      window.confirm(\n        \"Are you sure you want to mark this appointment as completed? This action cannot be undone.\"\n      )\n    ) {\n      const formData = new FormData();\n      formData.append(\"appointmentId\", appointment.id);\n      await submitMarkCompleted(formData);\n    }\n  };\n\n  // Handle save notes (doctor only)\n  const handleSaveNotes = async () => {\n    if (notesLoading || userRole !== \"DOCTOR\") return;\n\n    const formData = new FormData();\n    formData.append(\"appointmentId\", appointment.id);\n    formData.append(\"notes\", notes);\n    await submitNotes(formData);\n  };\n\n  // Handle join video call\n  const handleJoinVideoCall = async () => {\n    if (tokenLoading) return;\n\n    setAction(\"video\");\n\n    const formData = new FormData();\n    formData.append(\"appointmentId\", appointment.id);\n    await submitTokenRequest(formData);\n  };\n\n  // Handle successful operations\n  useEffect(() => {\n    if (cancelData?.success) {\n      toast.success(\"Appointment cancelled successfully\");\n      setOpen(false);\n      if (refetchAppointments) {\n        refetchAppointments();\n      } else {\n        router.refresh();\n      }\n    }\n  }, [cancelData, refetchAppointments, router]);\n\n  useEffect(() => {\n    if (completeData?.success) {\n      toast.success(\"Appointment marked as completed\");\n      setOpen(false);\n      if (refetchAppointments) {\n        refetchAppointments();\n      } else {\n        router.refresh();\n      }\n    }\n  }, [completeData, refetchAppointments, router]);\n\n  useEffect(() => {\n    if (notesData?.success) {\n      toast.success(\"Notes saved successfully\");\n      setAction(null);\n      if (refetchAppointments) {\n        refetchAppointments();\n      } else {\n        router.refresh();\n      }\n    }\n  }, [notesData, refetchAppointments, router]);\n\n  useEffect(() => {\n    if (tokenData?.success) {\n      // Redirect to video call page with token and session ID\n      router.push(\n        `/video-call?sessionId=${tokenData.videoSessionId}&token=${tokenData.token}&appointmentId=${appointment.id}`\n      );\n    } else if (tokenData?.error) {\n      setAction(null);\n    }\n  }, [tokenData, appointment.id, router]);\n\n  // Determine if appointment is active (within 30 minutes of start time)\n  const isAppointmentActive = () => {\n    const now = new Date();\n    const appointmentTime = new Date(appointment.startTime);\n    const appointmentEndTime = new Date(appointment.endTime);\n\n    // Can join 30 minutes before start until end time\n    return (\n      (appointmentTime.getTime() - now.getTime() <= 30 * 60 * 1000 &&\n        now < appointmentTime) ||\n      (now >= appointmentTime && now <= appointmentEndTime)\n    );\n  };\n\n  // Determine other party information based on user role\n  const otherParty =\n    userRole === \"DOCTOR\" ? appointment.patient : appointment.doctor;\n\n  const otherPartyLabel = userRole === \"DOCTOR\" ? \"Patient\" : \"Doctor\";\n  const otherPartyIcon = userRole === \"DOCTOR\" ? <User /> : <Stethoscope />;\n\n  return (\n    <>\n      <Card className=\"border-emerald-900/20 hover:border-emerald-700/30 transition-all\">\n        <CardContent className=\"p-4\">\n          <div className=\"flex flex-col md:flex-row justify-between gap-4\">\n            <div className=\"flex items-start gap-3\">\n              <div className=\"bg-muted/20 rounded-full p-2 mt-1\">\n                {otherPartyIcon}\n              </div>\n              <div>\n                <h3 className=\"font-medium text-white\">\n                  {userRole === \"DOCTOR\"\n                    ? otherParty.name\n                    : `Dr. ${otherParty.name}`}\n                </h3>\n                {userRole === \"DOCTOR\" && (\n                  <p className=\"text-sm text-muted-foreground\">\n                    {otherParty.email}\n                  </p>\n                )}\n                {userRole === \"PATIENT\" && (\n                  <p className=\"text-sm text-muted-foreground\">\n                    {otherParty.specialty}\n                  </p>\n                )}\n                <div className=\"flex items-center mt-2 text-sm text-muted-foreground\">\n                  <Calendar className=\"h-4 w-4 mr-1\" />\n                  <span>{formatDateTime(appointment.startTime)}</span>\n                </div>\n                <div className=\"flex items-center mt-1 text-sm text-muted-foreground\">\n                  <Clock className=\"h-4 w-4 mr-1\" />\n                  <span>\n                    {formatTime(appointment.startTime)} -{\" \"}\n                    {formatTime(appointment.endTime)}\n                  </span>\n                </div>\n              </div>\n            </div>\n            <div className=\"flex flex-col gap-2 self-end md:self-start\">\n              <Badge\n                variant=\"outline\"\n                className={\n                  appointment.status === \"COMPLETED\"\n                    ? \"bg-emerald-900/20 border-emerald-900/30 text-emerald-400\"\n                    : appointment.status === \"CANCELLED\"\n                    ? \"bg-red-900/20 border-red-900/30 text-red-400\"\n                    : \"bg-amber-900/20 border-amber-900/30 text-amber-400\"\n                }\n              >\n                {appointment.status}\n              </Badge>\n              <div className=\"flex gap-2 mt-2 flex-wrap\">\n                {canMarkCompleted() && (\n                  <Button\n                    size=\"sm\"\n                    onClick={handleMarkCompleted}\n                    disabled={completeLoading}\n                    className=\"bg-emerald-600 hover:bg-emerald-700\"\n                  >\n                    {completeLoading ? (\n                      <Loader2 className=\"h-4 w-4 animate-spin\" />\n                    ) : (\n                      <>\n                        <CheckCircle className=\"h-4 w-4 mr-1\" />\n                        Complete\n                      </>\n                    )}\n                  </Button>\n                )}\n                <Button\n                  size=\"sm\"\n                  variant=\"outline\"\n                  className=\"border-emerald-900/30\"\n                  onClick={() => setOpen(true)}\n                >\n                  View Details\n                </Button>\n              </div>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Appointment Details Dialog */}\n      <Dialog open={open} onOpenChange={setOpen}>\n        <DialogContent className=\"max-w-2xl\">\n          <DialogHeader>\n            <DialogTitle className=\"text-xl font-bold text-white\">\n              Appointment Details\n            </DialogTitle>\n            <DialogDescription>\n              {appointment.status === \"SCHEDULED\"\n                ? \"Manage your upcoming appointment\"\n                : \"View appointment information\"}\n            </DialogDescription>\n          </DialogHeader>\n\n          <div className=\"space-y-4 py-4\">\n            {/* Other Party Information */}\n            <div className=\"space-y-2\">\n              <h4 className=\"text-sm font-medium text-muted-foreground\">\n                {otherPartyLabel}\n              </h4>\n              <div className=\"flex items-center\">\n                <div className=\"h-5 w-5 text-emerald-400 mr-2\">\n                  {otherPartyIcon}\n                </div>\n                <div>\n                  <p className=\"text-white font-medium\">\n                    {userRole === \"DOCTOR\"\n                      ? otherParty.name\n                      : `Dr. ${otherParty.name}`}\n                  </p>\n                  {userRole === \"DOCTOR\" && (\n                    <p className=\"text-muted-foreground text-sm\">\n                      {otherParty.email}\n                    </p>\n                  )}\n                  {userRole === \"PATIENT\" && (\n                    <p className=\"text-muted-foreground text-sm\">\n                      {otherParty.specialty}\n                    </p>\n                  )}\n                </div>\n              </div>\n            </div>\n\n            {/* Appointment Time */}\n            <div className=\"space-y-2\">\n              <h4 className=\"text-sm font-medium text-muted-foreground\">\n                Scheduled Time\n              </h4>\n              <div className=\"flex flex-col gap-1\">\n                <div className=\"flex items-center\">\n                  <Calendar className=\"h-5 w-5 text-emerald-400 mr-2\" />\n                  <p className=\"text-white\">\n                    {formatDateTime(appointment.startTime)}\n                  </p>\n                </div>\n                <div className=\"flex items-center\">\n                  <Clock className=\"h-5 w-5 text-emerald-400 mr-2\" />\n                  <p className=\"text-white\">\n                    {formatTime(appointment.startTime)} -{\" \"}\n                    {formatTime(appointment.endTime)}\n                  </p>\n                </div>\n              </div>\n            </div>\n\n            {/* Status */}\n            <div className=\"space-y-2\">\n              <h4 className=\"text-sm font-medium text-muted-foreground\">\n                Status\n              </h4>\n              <Badge\n                variant=\"outline\"\n                className={\n                  appointment.status === \"COMPLETED\"\n                    ? \"bg-emerald-900/20 border-emerald-900/30 text-emerald-400\"\n                    : appointment.status === \"CANCELLED\"\n                    ? \"bg-red-900/20 border-red-900/30 text-red-400\"\n                    : \"bg-amber-900/20 border-amber-900/30 text-amber-400\"\n                }\n              >\n                {appointment.status}\n              </Badge>\n            </div>\n\n            {/* Patient Description */}\n            {appointment.patientDescription && (\n              <div className=\"space-y-2\">\n                <h4 className=\"text-sm font-medium text-muted-foreground\">\n                  {userRole === \"DOCTOR\"\n                    ? \"Patient Description\"\n                    : \"Your Description\"}\n                </h4>\n                <div className=\"p-3 rounded-md bg-muted/20 border border-emerald-900/20\">\n                  <p className=\"text-white whitespace-pre-line\">\n                    {appointment.patientDescription}\n                  </p>\n                </div>\n              </div>\n            )}\n\n            {/* Join Video Call Button */}\n            {appointment.status === \"SCHEDULED\" && (\n              <div className=\"space-y-2\">\n                <h4 className=\"text-sm font-medium text-muted-foreground\">\n                  Video Consultation\n                </h4>\n                <Button\n                  className=\"w-full bg-emerald-600 hover:bg-emerald-700\"\n                  disabled={\n                    !isAppointmentActive() || action === \"video\" || tokenLoading\n                  }\n                  onClick={handleJoinVideoCall}\n                >\n                  {tokenLoading || action === \"video\" ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                      Preparing Video Call...\n                    </>\n                  ) : (\n                    <>\n                      <Video className=\"h-4 w-4 mr-2\" />\n                      {isAppointmentActive()\n                        ? \"Join Video Call\"\n                        : \"Video call will be available 30 minutes before appointment\"}\n                    </>\n                  )}\n                </Button>\n              </div>\n            )}\n\n            {/* Doctor Notes (Doctor can view/edit, Patient can only view) */}\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center justify-between\">\n                <h4 className=\"text-sm font-medium text-muted-foreground\">\n                  Doctor Notes\n                </h4>\n                {userRole === \"DOCTOR\" &&\n                  action !== \"notes\" &&\n                  appointment.status !== \"CANCELLED\" && (\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => setAction(\"notes\")}\n                      className=\"h-7 text-emerald-400 hover:text-emerald-300 hover:bg-emerald-900/20\"\n                    >\n                      <Edit className=\"h-3.5 w-3.5 mr-1\" />\n                      {appointment.notes ? \"Edit\" : \"Add\"}\n                    </Button>\n                  )}\n              </div>\n\n              {userRole === \"DOCTOR\" && action === \"notes\" ? (\n                <div className=\"space-y-3\">\n                  <Textarea\n                    value={notes}\n                    onChange={(e) => setNotes(e.target.value)}\n                    placeholder=\"Enter your clinical notes here...\"\n                    className=\"bg-background border-emerald-900/20 min-h-[100px]\"\n                  />\n                  <div className=\"flex justify-end space-x-2\">\n                    <Button\n                      type=\"button\"\n                      variant=\"outline\"\n                      size=\"sm\"\n                      onClick={() => {\n                        setAction(null);\n                        setNotes(appointment.notes || \"\");\n                      }}\n                      disabled={notesLoading}\n                      className=\"border-emerald-900/30\"\n                    >\n                      Cancel\n                    </Button>\n                    <Button\n                      size=\"sm\"\n                      onClick={handleSaveNotes}\n                      disabled={notesLoading}\n                      className=\"bg-emerald-600 hover:bg-emerald-700\"\n                    >\n                      {notesLoading ? (\n                        <>\n                          <Loader2 className=\"mr-2 h-3.5 w-3.5 animate-spin\" />\n                          Saving...\n                        </>\n                      ) : (\n                        \"Save Notes\"\n                      )}\n                    </Button>\n                  </div>\n                </div>\n              ) : (\n                <div className=\"p-3 rounded-md bg-muted/20 border border-emerald-900/20 min-h-[80px]\">\n                  {appointment.notes ? (\n                    <p className=\"text-white whitespace-pre-line\">\n                      {appointment.notes}\n                    </p>\n                  ) : (\n                    <p className=\"text-muted-foreground italic\">\n                      No notes added yet\n                    </p>\n                  )}\n                </div>\n              )}\n            </div>\n          </div>\n\n          <DialogFooter className=\"flex flex-col-reverse sm:flex-row sm:justify-between sm:space-x-2\">\n            <div className=\"flex gap-2\">\n              {/* Mark as Complete Button - Only for doctors */}\n              {canMarkCompleted() && (\n                <Button\n                  onClick={handleMarkCompleted}\n                  disabled={completeLoading}\n                  className=\"bg-emerald-600 hover:bg-emerald-700\"\n                >\n                  {completeLoading ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                      Completing...\n                    </>\n                  ) : (\n                    <>\n                      <CheckCircle className=\"mr-2 h-4 w-4\" />\n                      Mark Complete\n                    </>\n                  )}\n                </Button>\n              )}\n\n              {/* Cancel Button - For scheduled appointments */}\n              {appointment.status === \"SCHEDULED\" && (\n                <Button\n                  variant=\"outline\"\n                  onClick={handleCancelAppointment}\n                  disabled={cancelLoading}\n                  className=\"border-red-900/30 text-red-400 hover:bg-red-900/10 mt-3 sm:mt-0\"\n                >\n                  {cancelLoading ? (\n                    <>\n                      <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                      Cancelling...\n                    </>\n                  ) : (\n                    <>\n                      <X className=\"h-4 w-4 mr-1\" />\n                      Cancel Appointment\n                    </>\n                  )}\n                </Button>\n              )}\n            </div>\n\n            <Button\n              onClick={() => setOpen(false)}\n              className=\"bg-emerald-600 hover:bg-emerald-700\"\n            >\n              Close\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}